<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python 基础难点]]></title>
    <url>%2F2018%2F10%2F08%2Fpython-%E5%9F%BA%E7%A1%80%E9%9A%BE%E7%82%B9%2F</url>
    <content type="text"><![CDATA[1.单例模式init 方法是什么 init 方法通常用在初始化一个类实例的时候]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[适用于本人的python快速复习资料（整理自第三方)]]></title>
    <url>%2F2018%2F09%2F29%2F%E9%80%82%E7%94%A8%E4%BA%8E%E6%9C%AC%E4%BA%BA%E7%9A%84python%E5%BF%AB%E9%80%9F%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99%EF%BC%88%E6%95%B4%E7%90%86%E8%87%AAlearn-x-in-y-minutes%2F</url>
    <content type="text"><![CDATA[太基础的东西自己就没有收录进来，本文会随着自己知识的增长而更新 #################################################### 1. 原始数据类型和运算符#################################################### # 除法例自动转换成浮点数35 / 5 # => 7.05 / 3 # => 1.6666666666666667 # 整数除法的结果都是向下取整5 // 3 # => 15.0 // 3.0 # => 1.0 # 浮点数也可以-5 // 3 # => -2-5.0 // 3.0 # => -2.0 # 浮点数的运算结果也是浮点数3 * 2.0 # => 6.0 # 模除（取余）7 % 3 # => 1 # 大小比较可以连起来！1 &lt; 2 &lt; 3 # => True2 &lt; 3 &lt; 2 # => False # 字符串可以被当作字符列表“This is a string”[0] # => ‘T’ # 用.format来格式化字符串“{} can be {}”.format(“strings”, “interpolated”) # =&gt; “strings can be interpolated” # 可以重复参数以节省时间“{0} be nimble, {0} be quick, {0} jump over the {1}”.format(“Jack”, “candle stick”)# => “Jack be nimble, Jack be quick, Jack jump over the candle stick” # 如果不想数参数，可以用关键字“{name} wants to eat {food}”.format(name=”Bob”, food=”lasagna”)# => “Bob wants to eat lasagna” # 如果你的Python3程序也要在Python2.5以下环境运行，也可以用老式的格式化语法“%s can be %s the %s way” % (“strings”, “interpolated”, “old”) # None是一个对象None # => None # 当与None进行比较时不要用 ==，要用is。is是用来比较两个变量是否指向同一个对象。“etc” is None # => FalseNone is None # => True #################################################### 2. 变量和集合#################################################### # print是内置的打印函数print(“I’m Python. Nice to meet you!”) # 在给变量赋值前不用提前声明# 传统的变量命名是小写，用下划线分隔单词some_var = 5some_var # => 5 # 访问未赋值的变量会抛出异常# 参考流程控制一段来学习异常处理some_unknown_var # 抛出NameError # 用列表(list)储存序列li = []# 创建列表时也可以同时赋给元素other_li = [4, 5, 6] # 用append在列表最后追加元素li.append(1) # li现在是[1]li.append(2) # li现在是[1, 2]li.append(4) # li现在是[1, 2, 4]li.append(3) # li现在是[1, 2, 4, 3]# 用pop从列表尾部删除li.pop() # => 3 且li现在是[1, 2, 4]# 把3再放回去li.append(3) # li变回[1, 2, 4, 3] # 列表存取跟数组一样li[0] # => 1# 取出最后一个元素li[-1] # => 3 # 越界存取会造成IndexErrorli[4] # 抛出IndexError # 列表有切割语法li[1:3] # => [2, 4]# 取尾li[2:] # => [4, 3]# 取头li[:3] # => [1, 2, 4]# 隔一个取一个li[::2] # =&gt;[1, 4]# 倒排列表li[::-1] # => [3, 4, 2, 1]# 可以用三个参数的任何组合来构建切割# li[始:终:步伐] # 用del删除任何一个元素del li[2] # li is now [1, 2, 3] # 列表可以相加# 注意：li和other_li的值都不变li + other_li # => [1, 2, 3, 4, 5, 6] # 用extend拼接列表li.extend(other_li) # li现在是[1, 2, 3, 4, 5, 6] # 用in测试列表是否包含值1 in li # => True # 用len取列表长度len(li) # => 6 # 元组是不可改变的序列tup = (1, 2, 3)tup[0] # => 1tup[0] = 3 # 抛出TypeError # 列表允许的操作元组大都可以len(tup) # => 3tup + (4, 5, 6) # => (1, 2, 3, 4, 5, 6)tup[:2] # => (1, 2)2 in tup # => True # 可以把元组合列表解包，赋值给变量a, b, c = (1, 2, 3) # 现在a是1，b是2，c是3# 元组周围的括号是可以省略的d, e, f = 4, 5, 6# 交换两个变量的值就这么简单e, d = d, e # 现在d是5，e是4 # 用字典表达映射关系empty_dict = {}# 初始化的字典filled_dict = {“one”: 1, “two”: 2, “three”: 3} # 用[]取值filled_dict[“one”] # => 1 # 用 keys 获得所有的键。# 因为 keys 返回一个可迭代对象，所以在这里把结果包在 list 里。我们下面会详细介绍可迭代。# 注意：字典键的顺序是不定的，你得到的结果可能和以下不同。list(filled_dict.keys()) # => [“three”, “two”, “one”] # 用values获得所有的值。跟keys一样，要用list包起来，顺序也可能不同。list(filled_dict.values()) # => [3, 2, 1] # 用in测试一个字典是否包含一个键“one” in filled_dict # => True1 in filled_dict # => False # 访问不存在的键会导致KeyErrorfilled_dict[“four”] # KeyError # 用get来避免KeyErrorfilled_dict.get(“one”) # => 1filled_dict.get(“four”) # => None# 当键不存在的时候get方法可以返回默认值filled_dict.get(“one”, 4) # => 1filled_dict.get(“four”, 4) # => 4 # setdefault方法只有当键不存在的时候插入新值filled_dict.setdefault(“five”, 5) # filled_dict[“five”]设为5filled_dict.setdefault(“five”, 6) # filled_dict[“five”]还是5 # 字典赋值filled_dict.update({“four”:4}) # => {“one”: 1, “two”: 2, “three”: 3, “four”: 4}filled_dict[“four”] = 4 # 另一种赋值方法 # 用del删除del filled_dict[“one”] # 从filled_dict中把one删除 # 用set表达集合empty_set = set()# 初始化一个集合，语法跟字典相似。some_set = {1, 1, 2, 2, 3, 4} # some_set现在是{1, 2, 3, 4} # 可以把集合赋值于变量filled_set = some_set # 为集合添加元素filled_set.add(5) # filled_set现在是{1, 2, 3, 4, 5} # &amp; 取交集other_set = {3, 4, 5, 6}filled_set &amp; other_set # => {3, 4, 5} # | 取并集filled_set | other_set # => {1, 2, 3, 4, 5, 6} # - 取补集{1, 2, 3, 4} - {2, 3, 5} # => {1, 4} # in 测试集合是否包含元素2 in filled_set # => True10 in filled_set # => False #################################################### 3. 流程控制和迭代器#################################################### # 先随便定义一个变量some_var = 5 # 这是个if语句。注意缩进在Python里是有意义的# 印出”some_var比10小”if some_var &gt; 10:​ print(“some_var比10大”)elif some_var &lt; 10: # elif句是可选的​ print(“some_var比10小”)else: # else也是可选的​ print(“some_var就是10”) “””用for循环语句遍历列表打印: dog is a mammal cat is a mammal mouse is a mammal“””for animal in [“dog”, “cat”, “mouse”]:​ print(“{} is a mammal”.format(animal)) “””“range(number)”返回数字列表从0到给的数字打印: 0 1 2 3“””for i in range(4):​ print(i) “””while循环直到条件不满足打印: 0 1 2 3“””x = 0while x &lt; 4:​ print(x)​ x += 1 # x = x + 1 的简写 # 用try/except块处理异常状况try:​ # 用raise抛出异常​ raise IndexError(“This is an index error”)except IndexError as e:​ pass # pass是无操作，但是应该在这里处理错误except (TypeError, NameError):​ pass # 可以同时处理不同类的错误else: # else语句是可选的，必须在所有的except之后​ print(“All good!”) # 只有当try运行完没有错误的时候这句才会运行 # Python提供一个叫做可迭代(iterable)的基本抽象。一个可迭代对象是可以被当作序列# 的对象。比如说上面range返回的对象就是可迭代的。 filled_dict = {“one”: 1, “two”: 2, “three”: 3}our_iterable = filled_dict.keys()print(our_iterable) # => dict_keys([‘one’, ‘two’, ‘three’])，是一个实现可迭代接口的对象 # 可迭代对象可以遍历for i in our_iterable:​ print(i) # 打印 one, two, three # 但是不可以随机访问our_iterable[1] # 抛出TypeError # 可迭代对象知道怎么生成迭代器our_iterator = iter(our_iterable) # 迭代器是一个可以记住遍历的位置的对象# 用__next__可以取得下一个元素our_iterator.__next__() # => “one” # 再一次调取__next__时会记得位置our_iterator.__next__() # => “two”our_iterator.__next__() # => “three” # 当迭代器所有元素都取出后，会抛出StopIterationour_iterator.__next__() # 抛出StopIteration # 可以用list一次取出迭代器所有的元素list(filled_dict.keys()) # => Returns [“one”, “two”, “three”] #################################################### 4. 函数#################################################### # 用def定义新函数def add(x, y):​ print(“x is {} and y is {}”.format(x, y))​ return x + y # 用return语句返回 # 调用函数add(5, 6) # => 印出”x is 5 and y is 6”并且返回11 # 也可以用关键字参数来调用函数add(y=6, x=5) # 关键字参数可以用任何顺序 # 我们可以定义一个可变参数函数def varargs(*args):​ return args varargs(1, 2, 3) # => (1, 2, 3) # 我们也可以定义一个关键字可变参数函数def keyword_args(**kwargs):​ return kwargs # 我们来看看结果是什么：keyword_args(big=”foot”, loch=”ness”) # => {“big”: “foot”, “loch”: “ness”} # 这两种可变参数可以混着用def all_the_args(*args, **kwargs):​ print(args)​ print(kwargs)“””all_the_args(1, 2, a=3, b=4) prints: (1, 2) {“a”: 3, “b”: 4}“”” # 调用可变参数函数时可以做跟上面相反的，用展开序列，用**展开字典。args = (1, 2, 3, 4)kwargs = {“a”: 3, “b”: 4}all_the_args(args) # 相当于 foo(1, 2, 3, 4)all_the_args(kwargs) # 相当于 foo(a=3, b=4)all_the_args(*args, kwargs) # 相当于 foo(1, 2, 3, 4, a=3, b=4) # 函数作用域x = 5 def setX(num):​ # 局部作用域的x和全局域的x是不同的​ x = num # => 43​ print (x) # => 43 def setGlobalX(num):​ global x​ print (x) # => 5​ x = num # 现在全局域的x被赋值​ print (x) # => 6 setX(43)setGlobalX(6) # 函数在Python是一等公民def create_adder(x):​ def adder(y):​ return x + y​ return adder add_10 = create_adder(10)add_10(3) # => 13 # 也有匿名函数(lambda x: x &gt; 2)(3) # => True # 内置的高阶函数map(add_10, [1, 2, 3]) # => [11, 12, 13]filter(lambda x: x &gt; 5, [3, 4, 5, 6, 7]) # => [6, 7] # 用列表推导式可以简化映射和过滤。列表推导式的返回值是另一个列表。[add_10(i) for i in [1, 2, 3]] # => [11, 12, 13][x for x in [3, 4, 5, 6, 7] if x &gt; 5] # => [6, 7] #################################################### 5. 类#################################################### # 定义一个继承object的类class Human(object): \# 类属性，被所有此类的实例共用。 species = &quot;H. sapiens&quot; \# 构造方法，当实例被初始化时被调用。注意名字前后的双下划线，这是表明这个属 \# 性或方法对Python有特殊意义，但是允许用户自行定义。你自己取名时不应该用这 \# 种格式。 def \_\_init\_\_(self, name): \# Assign the argument to the instance&apos;s name attribute self.name = name \# 实例方法，第一个参数总是self，就是这个实例对象 def say(self, msg): return &quot;{name}: {message}&quot;.format(name=self.name, message=msg) \# 类方法，被所有此类的实例共用。第一个参数是这个类对象。 @classmethod def get_species(cls): return cls.species \# 静态方法。调用时没有实例或类的绑定。 @staticmethod def grunt(): return &quot;\*grunt\*&quot; # 构造一个实例i = Human(name=”Ian”)print(i.say(“hi”)) # 印出 “Ian: hi” j = Human(“Joel”)print(j.say(“hello”)) # 印出 “Joel: hello” # 调用一个类方法i.get_species() # => “H. sapiens” # 改一个共用的类属性Human.species = “H. neanderthalensis”i.get_species() # => “H. neanderthalensis”j.get_species() # => “H. neanderthalensis” # 调用静态方法Human.grunt() # => “*grunt*“ #################################################### 6. 模块#################################################### # 用import导入模块import mathprint(math.sqrt(16)) # => 4.0 # 也可以从模块中导入个别值from math import ceil, floorprint(ceil(3.7)) # => 4.0print(floor(3.7)) # => 3.0 # 可以导入一个模块中所有值# 警告：不建议这么做from math import * # 如此缩写模块名字import math as mmath.sqrt(16) == m.sqrt(16) # => True # Python模块其实就是普通的Python文件。你可以自己写，然后导入，# 模块的名字就是文件的名字。 # 你可以这样列出一个模块里所有的值import mathdir(math) #################################################### 7. 高级用法#################################################### # 用生成器(generators)方便地写惰性运算def double_numbers(iterable):​ for i in iterable:​ yield i + i # 生成器只有在需要时才计算下一个值。它们每一次循环只生成一个值，而不是把所有的# 值全部算好。## range的返回值也是一个生成器，不然一个1到900000000的列表会花很多时间和内存。## 如果你想用一个Python的关键字当作变量名，可以加一个下划线来区分。range_ = range(1, 900000000)# 当找到一个 &gt;=30 的结果就会停# 这意味着 `double_numbers` 不会生成大于30的数。for i in double_numbers(range_):​ print(i)​ if i &gt;= 30:​ break # 装饰器(decorators)# 这个例子中，beg装饰say# beg会先调用say。如果返回的say_please为真，beg会改变返回的字符串。from functools import wraps def beg(target_function):​ @wraps(target_function)​ def wrapper(args, **kwargs):​ msg, say_please = target_function(args, **kwargs)​ if say_please:​ return “{} {}”.format(msg, “Please! I am poor :(“)​ return msg return wrapper @begdef say(say_please=False):​ msg = “Can you buy me a beer?”​ return msg, say_please print(say()) # Can you buy me a beer?print(say(say_please=True)) # Can you buy me a beer? Please! I am poor :(]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一名优雅的资源帝]]></title>
    <url>%2F2018%2F09%2F27%2F%E4%B8%80%E5%90%8D%E4%BC%98%E9%9B%85%E7%9A%84%E8%B5%84%E6%BA%90%E5%B8%9D%2F</url>
    <content type="text"><![CDATA[emmm公屏只分享符合社会主义核心价值观的资源，侵权即删，只做你私人的搜索引擎~Disclaimer: This site is established in mainland China to comply with local laws and doesn’t make profit demand. Visitors in other regions are required to abide by local laws. If you have any questions, please email. 如果你想要XXX资源请邮箱联系我，或在评论区留言。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>资源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos6到7的命令变化]]></title>
    <url>%2F2018%2F09%2F25%2Fcentos6%E5%88%B07%E7%9A%84%E5%91%BD%E4%BB%A4%E5%8F%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[防火墙在CentOS6中为 iptables，在CentOS7中变为 firewalld。service iptables stop/start/restartsystemctl stop/start/restart firewalld 操作服务的改变原来的service+服务进程+操作变为systemctl+操作+服务，顺序稍 微改变了一下，用起来可能不是很顺手，熟悉以后没什么大问题。 服务进程可以记为：systemctl+操作+服务 IP地址[CentOS6]ifconfig[CentOS7]ip address show/ip addr发现ifconfig同样适用CentOS7，ip变为ens… 主机名的位置也发生了变化[CentOS6] /etc/sysconfig/network[CentOS7] /etc/hostname 开机启动/关闭[CentOS6]chkconfig service_name on/off [CentOS7]systemctl enable service_namesystemctl disable service_name 后台进程[CentOS6]netstat[CentOS7]ss]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linnux 根目录说明]]></title>
    <url>%2F2018%2F09%2F20%2Flinux-%E6%A0%B9%E7%9B%AE%E5%BD%95%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[当在使用Linux的时候，如果您通过ls –l / 就会发现，在/下包涵很多的目录，比如etc、usr、var、bin … … 等目录，而在这些目录中，我们进去看看，发现也有很多的目录或文件。文件系统在Linux下看上去就象树形结构，所以我们可以把文件系统的结构形象的称为 树形结构。 文件系统的是用来组织和排列文件存取的，所以她是可见的，在Linux中，我们可以通过ls等工具来查看其结构，在Linux系统中，我们见到的都是树形结构；比如操作系统安装在一个文件系统中，他表现为由/ 起始的树形结构。linux文件系统的最顶端是/，我们称/为Linux的root，也就是 Linux操作系统的文件系统。Linux的文件系统的入口就是/，所有的目录、文件、设备都在/之下，/就是Linux文件系统的组织者，也是最上级的领导者。 由于linux是开放源代码，各大公司和团体根据linux的核心代码做各自的操作，编程。这样就造成在根下的目录的不同。这样就造成个人不能使用他人的linux系统的PC。因为你根本不知道一些基本的配置，文件在哪里。。。这就造成了混乱。这就是FHS（Filesystem Hierarchy Standard ）机构诞生的原因。该机构是linux爱好者自发的组成的一个团体，主要是是对linux做一些基本的要求，不至于是操作者换一台主机就成了linux的‘文盲’。 根据FHS(http://www.pathname.com/fhs/)的官方文件指出， 他们的主要目的是希望让使用者可以了解到已安装软件通常放置于那个目录下， 所以他们希望独立的软件开发商、操作系统制作者、以及想要维护系统的用户，都能够遵循FHS的标准。 也就是说，FHS的重点在于规范每个特定的目录下应该要放置什么样子的数据而已。 这样做好处非常多，因为Linux操作系统就能够在既有的面貌下(目录架构不变)发展出开发者想要的独特风格。 事实上，FHS是根据过去的经验一直再持续的改版的，FHS依据文件系统使用的频繁与否与是否允许使用者随意更动， 四种类型:1.可分享的： 可以分享给其他系统挂载使用的目录，所以包括执行文件与用户的邮件等数据， 是能够分享给网络上其他主机挂载用的目录； 2.不可分享的： 自己机器上面运作的装置文件或者是与程序有关的socket文件等， 由于仅与自身机器有关，所以当然就不适合分享给其他主机了。 3.不变的： 有些数据是不会经常变动的，跟随着distribution而不变动。 例如函式库、文件说明文件、系统管理员所管理的主机服务配置文件等等； 4.可变动的： 经常改变的数据，例如登录文件、一般用户可自行收受的新闻组等。 事实上，FHS针对目录树架构仅定义出三层目录底下应该放置什么数据而已，分别是底下这三个目录的定义： / (root, 根目录)：与开机系统有关； /usr (unix software resource)：与软件安装/执行有关； /var (variable)：与系统运作过程有关。 根目录 (/) 的意义与内容： 根目录是整个系统最重要的一个目录，因为不但所有的目录都是由根目录衍生出来的， 同时根目录也与开机/还原/系统修复等动作有关。 由于系统开机时需要特定的开机软件、核心文件、开机所需程序、 函式库等等文件数据，若系统出现错误时，根目录也必须要包含有能够修复文件系统的程序才行。 因为根目录是这么的重要，所以在FHS的要求方面，他希望根目录不要放在非常大的分区， 因为越大的分区内你会放入越多的数据，如此一来根目录所在分区就可能会有较多发生错误的机会。 因此FHS标准建议：根目录(/)所在分区应该越小越好， 且应用程序所安装的软件最好不要与根目录放在同一个分区内，保持根目录越小越好。 如此不但效能较佳，根目录所在的文件系统也较不容易发生问题。说白了，就是根目录和Windows的C盘一个样。 根据以上原因，FHS认为根目录(/)下应该包含如下子目录： /bin：系统有很多放置执行档的目录，但/bin比较特殊。因为/bin放置的是在单人维护模式下还能够被操作的指令。在/bin底下的指令可以被root与一般帐号所使用，主要有：cat,chmod(修改权限), chown, date, mv, mkdir, cp, bash等等常用的指令。 /boot：主要放置开机会使用到的档案，包括Linux核心档案以及开机选单与开机所需设定档等等。Linux kernel常用的档名为：vmlinuz ，如果使用的是grub这个开机管理程式，则还会存在/boot/grub/这个目录。 /dev：在Linux系统上，任何装置与周边设备都是以档案的型态存在于这个目录当中。 只要通过存取这个目录下的某个档案，就等于存取某个装置。比要重要的档案有/dev/null, /dev/zero, /dev/tty , /dev/lp, / dev/hd, /dev/sd*等等 /etc：系统主要的设定档几乎都放置在这个目录内，例如人员的帐号密码档、各种服务的启始档等等。 一般来说，这个目录下的各档案属性是可以让一般使用者查阅的，但是只有root有权力修改。 FHS建议不要放置可执行档(binary)在这个目录中。 比较重要的档案有：/etc/inittab, /etc/init.d/, /etc/modprobe.conf, /etc/X11/, /etc/fstab, /etc/sysconfig/等等。 另外，其下重要的目录有：/etc/init.d/ ：所有服务的预设启动script都是放在这里的，例如要启动或者关闭iptables的话： /etc/init.d/iptables start、/etc/init.d/ iptables stop /etc/xinetd.d/ ：这就是所谓的super daemon管理的各项服务的设定档目录。 /etc/X11/ ：与X Window有关的各种设定档都在这里，尤其是xorg.conf或XF86Config这两个X Server的设定档。 /home：这是系统预设的使用者家目录(home directory)。 在你新增一个一般使用者帐号时，预设的使用者家目录都会规范到这里来。比较重要的是，家目录有两种代号： ~ ：代表当前使用者的家目录， ~guest：则代表用户名为guest的家目录。 /lib：系统的函式库非常的多，而/lib放置的则是在开机时会用到的函式库，以及在/bin或/sbin底下的指令会呼叫的函式库而已 。 什么是函式库呢？妳可以将他想成是外挂，某些指令必须要有这些外挂才能够顺利完成程式的执行之意。 尤其重要的是/lib/modules/这个目录，因为该目录会放置核心相关的模组(驱动程式)。 /media：media是媒体的英文，顾名思义，这个/media底下放置的就是可移除的装置。 包括软碟、光碟、DVD等等装置都暂时挂载于此。 常见的档名有：/media/floppy, /media/cdrom等等。 /mnt：如果妳想要暂时挂载某些额外的装置，一般建议妳可以放置到这个目录中。在古早时候，这个目录的用途与/media相同啦。 只是有了/media之后，这个目录就用来暂时挂载用了。 /opt：这个是给第三方协力软体放置的目录 。 什么是第三方协力软体啊？举例来说，KDE这个桌面管理系统是一个独立的计画，不过他可以安装到Linux系统中，因此KDE的软体就建议放置到此目录下了。 另外，如果妳想要自行安装额外的软体(非原本的distribution提供的)，那么也能够将你的软体安装到这里来。 不过，以前的Linux系统中，我们还是习惯放置在/usr/local目录下。 /root：系统管理员(root)的家目录。 之所以放在这里，是因为如果进入单人维护模式而仅挂载根目录时，该目录就能够拥有root的家目录，所以我们会希望root的家目录与根目录放置在同一个分区中。 /sbin：Linux有非常多指令是用来设定系统环境的，这些指令只有root才能够利用来设定系统，其他使用者最多只能用来查询而已。放在/sbin底下的为开机过程中所需要的，里面包括了开机、修复、还原系统所需要的指令。至于某些伺服器软体程式，一般则放置到/usr/sbin/当中。至于本机自行安装的软体所产生的系统执行档(system binary)，则放置到/usr/local/sbin/当中了。常见的指令包括：fdisk, fsck, ifconfig, init, mkfs等等。 /srv：srv可以视为service的缩写，是一些网路服务启动之后，这些服务所需要取用的资料目录。 常见的服务例如WWW, FTP等等。 举例来说，WWW伺服器需要的网页资料就可以放置在/srv/www/里面。呵呵，看来平时我们编写的代码应该放到这里了。 /tmp：这是让一般使用者或者是正在执行的程序暂时放置档案的地方。这个目录是任何人都能够存取的，所以你需要定期的清理一下。当然，重要资料不可放置在此目录啊。 因为FHS甚至建议在开机时，应该要将/tmp下的资料都删除。 事实上FHS针对根目录所定义的标准就仅限于上表，不过仍旧有些目录也需要我们了解一下，具体如下： /lost+found：这个目录是使用标准的ext2/ext3档案系统格式才会产生的一个目录，目的在于当档案系统发生错误时，将一些遗失的片段放置到这个目录下。 这个目录通常会在分割槽的最顶层存在，例如你加装一个硬盘于/disk中，那在这个系统下就会自动产生一个这样的目录/disk/lost+found /proc：这个目录本身是一个虚拟文件系统(virtual filesystem)喔。 他放置的资料都是在内存当中，例如系统核心、行程资讯(process)（是进程吗?）、周边装置的状态及网络状态等等。因为这个目录下的资料都是在记忆体（内存）当中，所以本身不占任何硬盘空间。比较重要的档案（目录）例如： /proc/cpuinfo, /proc/dma, /proc/interrupts, /proc/ioports, /proc/net/*等等。呵呵，是虚拟内存吗[guest]？ /sys：这个目录其实跟/proc非常类似，也是一个虚拟的档案系统，主要也是记录与核心相关的资讯。 包括目前已载入的核心模组与核心侦测到的硬体装置资讯等等。 这个目录同样不占硬盘容量。 除了这些目录的内容之外，另外要注意的是，因为根目录与开机有关，开机过程中仅有根目录会被挂载， 其他分区则是在开机完成之后才会持续的进行挂载的行为。就是因为如此，因此根目录下与开机过程有关的目录， 就不能够与根目录放到不同的分区去。 那哪些目录不可与根目录分开呢？有底下这些： /etc：配置文件 /bin：重要执行档 /dev：所需要的装置文件 /lib：执行档所需的函式库与核心所需的模块 /sbin：重要的系统执行文件 这五个目录千万不可与根目录分开在不同的分区。请背下来啊。 /usr 的意义与内容： 依据FHS的基本定义，/usr里面放置的数据属于可分享的与不可变动的(shareable, static)， 如果你知道如何透过网络进行分区的挂载(例如在服务器篇会谈到的NFS服务器)，那么/usr确实可以分享给局域网络内的其他主机来使用喔。 /usr不是user的缩写，其实usr是Unix Software Resource的缩写， 也就是Unix操作系统软件资源所放置的目录，而不是用户的数据啦。这点要注意。 FHS建议所有软件开发者，应该将他们的数据合理的分别放置到这个目录下的次目录，而不要自行建立该软件自己独立的目录。 因为是所有系统默认的软件(distribution发布者提供的软件)都会放置到/usr底下，因此这个目录有点类似Windows 系统的C:\Windows\ + C:\Program files\这两个目录的综合体，系统刚安装完毕时，这个目录会占用最多的硬盘容量。 一般来说，/usr的次目录建议有底下这些： /usr/X11R6/：为X Window System重要数据所放置的目录，之所以取名为X11R6是因为最后的X版本为第11版，且该版的第6次释出之意。 /usr/bin/：绝大部分的用户可使用指令都放在这里。请注意到他与/bin的不同之处。(是否与开机过程有关) /usr/include/：c/c++等程序语言的档头(header)与包含档(include)放置处，当我们以tarball方式 (*.tar.gz 的方式安装软件)安装某些数据时，会使用到里头的许多包含档。 /usr/lib/：包含各应用软件的函式库、目标文件(object file)，以及不被一般使用者惯用的执行档或脚本(script)。 某些软件会提供一些特殊的指令来进行服务器的设定，这些指令也不会经常被系统管理员操作， 那就会被摆放到这个目录下啦。要注意的是，如果你使用的是X86_64的Linux系统， 那可能会有/usr/lib64/目录产生 /usr/local/：统管理员在本机自行安装自己下载的软件(非distribution默认提供者)，建议安装到此目录， 这样会比较便于管理。举例来说，你的distribution提供的软件较旧，你想安装较新的软件但又不想移除旧版， 此时你可以将新版软件安装于/usr/local/目录下，可与原先的旧版软件有分别啦。 你可以自行到/usr/local去看看，该目录下也是具有bin, etc, include, lib…的次目录 /usr/sbin/：非系统正常运作所需要的系统指令。最常见的就是某些网络服务器软件的服务指令(daemon) /usr/share/：放置共享文件的地方，在这个目录下放置的数据几乎是不分硬件架构均可读取的数据， 因为几乎都是文本文件嘛。在此目录下常见的还有这些次目录：/usr/share/man：联机帮助文件 /usr/share/doc：软件杂项的文件说明 /usr/share/zoneinfo：与时区有关的时区文件 /usr/src/：一般原始码建议放置到这里，src有source的意思。至于核心原始码则建议放置到/usr/src/linux/目录下。 /var 的意义与内容： 如果/usr是安装时会占用较大硬盘容量的目录，那么/var就是在系统运作后才会渐渐占用硬盘容量的目录。 因为/var目录主要针对常态性变动的文件，包括缓存(cache)、登录档(log file)以及某些软件运作所产生的文件， 包括程序文件(lock file, run file)，或者例如MySQL数据库的文件等等。常见的次目录有： /var/cache/：应用程序本身运作过程中会产生的一些暂存档 /var/lib/：程序本身执行的过程中，需要使用到的数据文件放置的目录。在此目录下各自的软件应该要有各自的目录。 举例来说，MySQL的数据库放置到/var/lib/mysql/而rpm的数据库则放到/var/lib/rpm去 /var/lock/：某些装置或者是文件资源一次只能被一个应用程序所使用，如果同时有两个程序使用该装置时， 就可能产生一些错误的状况，因此就得要将该装置上锁(lock)，以确保该装置只会给单一软件所使用。 举例来说，刻录机正在刻录一块光盘，你想一下，会不会有两个人同时在使用一个刻录机烧片？ 如果两个人同时刻录，那片子写入的是谁的数据？所以当第一个人在刻录时该刻录机就会被上锁， 第二个人就得要该装置被解除锁定(就是前一个人用完了)才能够继续使用 /var/log/：非常重要。这是登录文件放置的目录。里面比较重要的文件如/var/log/messages, /var/log/wtmp(记录登入者的信息)等。 /var/mail/：放置个人电子邮件信箱的目录，不过这个目录也被放置到/var/spool/mail/目录中，通常这两个目录是互为链接文件。 /var/run/：某些程序或者是服务启动后，会将他们的PID放置在这个目录下 /var/spool/：这个目录通常放置一些队列数据，所谓的“队列”就是排队等待其他程序使用的数据。 这些数据被使用后通常都会被删除。举例来说，系统收到新信会放置到/var/spool/mail/中， 但使用者收下该信件后该封信原则上就会被删除。信件如果暂时寄不出去会被放到/var/spool/mqueue/中， 等到被送出后就被删除。如果是工作排程数据(crontab)，就会被放置到/var/spool/cron/目录中。 由于FHS仅是定义出最上层(/)及次层(/usr, /var)的目录内容应该要放置的文件或目录数据， 因此，在其他次目录层级内，就可以随开发者自行来配置了。 目录树(directory tree) : 在Linux底下，所有的文件与目录都是由根目录开始的。那是所有目录与文件的源头, 然后再一个一个的分支下来，因此，我们也称这种目录配置方式为：目录树(directory tree), 这个目录树的主要特性有： 目录树的启始点为根目录 (/, root)； 每一个目录不止能使用本地端的 partition 的文件系统，也可以使用网络上的 filesystem 。举例来说， 可以利用 Network File System (NFS) 服务器挂载某特定目录等。 每一个文件在此目录树中的文件名(包含完整路径)都是独一无二的。如果我们将整个目录树以图的方法来显示，并且将较为重要的文件数据列出来的话． enter code here绝对路径与相对路径 除了需要特别注意的FHS目录配置外，在文件名部分我们也要特别注意。因为根据档名写法的不同，也可将所谓的路径(path)定义为绝对路径(absolute)与相对路径(relative)。 这两种文件名/路径的写法依据是这样的： 绝对路径：由根目录(/)开始写起的文件名或目录名称， 例如 /home/dmtsai/.bashrc； 相对路径：相对于目前路径的文件名写法。 例如 ./home/n1516 或 等等。反正开头不是 / 就属于相对路径的写法 而你必须要了解，相对路径是以你当前所在路径的相对位置来表示的。举例来说，你目前在 /home 这个目录下， 如果想要进入 /var/log 这个目录时，可以怎么写呢？ 123cd /var/log (absolute)cd ../var/log (relative) 因为你在 /home 底下，所以要回到上一层 (../) 之后，才能继续往 /var 来移动的，特别注意这两个特殊的目录： . ：代表当前的目录，也可以使用 ./ 来表示； .. ：代表上一层目录，也可以 ../ 来代表。 这个 . 与 .. 目录概念是很重要的，你常常会看到 cd .. 或 ./command 之类的指令下达方式， 就是代表上一层与目前所在目录的工作状态。 实例1：如何先进入/var/spool/mail/目录，再进入到/var/spool/cron/目录内？ 命令：cd /var/spool/mailcd ../cron说明： 由于/var/spool/mail与/var/spool/cron是同样在/var/spool/目录中。如此就不需要在由根目录开始写起了。这个相对路径是非常有帮助的，尤其对于某些软件开发商来说。 一般来说，软件开发商会将数据放置到/usr/local/里面的各相对目录。 但如果用户想要安装到不同目录呢？就得要使用相对路径。 实例2：网络文件常常提到类似./run.sh之类的数据，这个指令的意义为何？说明： 由于指令的执行需要变量的支持，若你的执行文件放置在本目录，并且本目录并非正规的执行文件目录(/bin, /usr/bin等为正规)，此时要执行指令就得要严格指定该执行档。./代表本目录的意思，所以./run.sh代表执行本目录下， 名为run.sh的文件。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闰一先生的建站之旅]]></title>
    <url>%2F2018%2F09%2F18%2F%E9%97%B0%E4%B8%80%E5%85%88%E7%94%9F%E7%9A%84%E5%BB%BA%E7%AB%99%E4%B9%8B%E6%97%85%2F</url>
    <content type="text"><![CDATA[生活就像做饭一样，你得先买菜，洗菜，做菜，吃完还要洗碗。建站也是，这里记录我的建站踩坑之旅，以及后期的更新维护。 最开始你需要准备的“原料”1.一台可以上网的私人电脑，不建议在公共电脑操作（操作系统为主流的window7及以上）； 2.GitHub账号，注册方式自行百度，这里提醒一下，为了不踩坑，记得注册的时候用户名字母一定要小写，且没有特殊字符，最好就是好几的小写英文或者汉语拼音，eg. “langwang”,”xiaohong”,”innocencepp”等，这个用户名决定了你初期域名的样子，不要太复杂的，我的是runyixs； 3.所需安装的软件：git；node.js,markdown语法编辑器这里我推荐小书屋（Typora也不错其实）。 把上文提及的软件安装一通，小白用户请点这里下载 一路next就OK。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>域名</tag>
        <tag>logo</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[window自用命令]]></title>
    <url>%2F2018%2F09%2F18%2Fwindow%E8%87%AA%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[查看所有进程占用的端口在开始-运行-cmd,输入：netstat –ano 可以查看所有进程 查看占用指定端口的程序当你在用tomcat发布程序时，经常会遇到端口被占用的情况，我们想知道是哪个程序或进程占用了端口，可以用该命令 netstat –ano|findstr [指定端口号] 如：查询占用了8080端口的进程：netstat -ano|findstr “8080” 通过任务管理器杀死相关的进程方法一：使用任务管理器杀死进程打开任务管理器-&gt;查看-&gt;选择列-&gt;然后勾选PID选项，回到任务管理器上可以查看到对应的pid，然后结束进程 当然上面的方法有时候不好用，就是任务管理器中的进程比较多的时候，然后去找到对应的进程是很麻烦的，所以还有一种方法可以杀死进程的 方法二：使用命令杀死进程1&gt;首先找到进程号对应的进程名称tasklist|findstr [进程号]；如：tasklist|findstr 3112 2&gt;然后根据进程名称杀死进程taskkill /f /t /im [进程名称]；如：taskkill /f /t /im /javaw.exe]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>window</tag>
        <tag>端口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从搭建个人博客中学习DNS(域名服务器)解析]]></title>
    <url>%2F2018%2F09%2F14%2F%E4%BB%8E%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E4%B8%AD%E5%AD%A6%E4%B9%A0DNS-%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8-%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[从搭建hexo个人博客过程中理解学习DNS解析转载自原作者 最近，新接触到了hexo这个博客工具，并利用它搭建了基于git hub pages静态页面的个人博客站，绑定了自己的域名，在绑定域名这个环节，逐步学习并理解了域名解析这个过程，想到之前有个有趣的面试题就是“当你在浏览器地址栏中输入一个网址，并按下回车键后，发生了什么”，于是就想把此记录下。 DNS基础知识DNS(domain name system) 从概念上来说，Internet被分成200多个顶级域，每个域名有多个主机。顶级域有两种：通用域和国家域。 域名不区分大小写 资源记录每个域都可以有一组与它相关联的资源记录。对于一台主机来说，最常见的资源记录就是他的IP地址，但除此之外，还存在许多其他种类的资源记录。因此DNS的基本功能是将域名映射到资源记录上。 资源记录是一个五元组，使用如下格式： 类型 含义 值 SOC 授权的开始 本区域的参数 A 一台主机的ip地址 32位整数 MX 邮件交换 优先级，希望接受该域电子邮件的机器 NS 名字服务器 本域的服务器名称 CNAME 规范名 域名 PTR 指针 一个IP地址的别名 HINFO 主机的描述 用ASCII表示的cpu和操作系统 TXT 文本 未解释的ASCII码文本 最重要的是A(Address，地址)记录，他包含了某一台主机的32位IP地址，每台Internet主机必须有一个IP地址，以便其他机器能与他进行通信。 其次最重要的记录类型是MX记录，他也指定一台主机的名字，该主机将为这个特定的域接受电子邮件。之所以使用MX记录，是因为并非每台机器都做好了接受电子邮件的准备。 NS记录指定名字服务器。 CNAME记录允许创建别名。例如，如果一个人很熟悉Internet的常规命名规则，他打算给MIT计算机科学西的一个人发送一个消息，而且他只知道此人的登录名为paul，那么，他可能猜测此人的邮件地址是paul@cs.mit.edu。事实上这个地址并不正常，因为MIT计算机科学系的域是lcs.mit.edu。但是，MIT可以创建一条CNAME记录，以便为那些不知情的人和程序指引到正确的方向上，这也算是为他们提供一项服务吧。 与CNAME一样，PTR也指向了另一个名字。但是CNAME只是一个宏定义，而PTR与CNAME不同，它是一种正规的DNS数据类型，他的确切含义要取决于他所在的上下文。在实践中，PTR几乎总是被用来将一个名字与一个IP地址关联起来，以便能够查找IP地址并返回对应机器的名字，这种功能被称为反向查找（reverse lookups） HINFO 记录允许人们找到一个域对应于哪种操作机器和操作系统。 TXT 记录，每个域可以按照任意的方式来标识自己。 Value域，他的值可以是数字，域名或者ASCII字符串，其语义取决于记录的类型。 DNS域名称类型 名称类型 说明 示例 根域(Root domain) 这是表示未命名的等级; 目录树的顶部它有时显示为两个空引号 (“”)，表示空值。 DNS 域名中使用时，它规定由尾部句点 (.) 来指定名称位于根或更高级别的域层次结构。 在此情况下，DNS 域名被认为是完整和点到准确的位置在树中的名称。 本区域的参数 A 一台主机的ip地址 32位整数 MX 邮件交换 优先级，希望接受该域电子邮件的机器 NS 名字服务器 本域的服务器名称 CNAME 规范名 域名 PTR 指针 一个IP地址的别名 HINFO 主机的描述 用ASCII表示的cpu和操作系统 TXT 文本 未解释的ASCII码文本 域名解析域名解析过程 浏览器缓存：浏览器会首先检查缓存中有没有该域名的缓存记录，如果有，解析过程结束，如果没有，继续下一步。浏览器会缓存DNS记录一段时间，时间，大小等通过TTL设置。 系统缓存：在浏览器缓存里没有找到记录，浏览器会做一个系统调用，查找系统缓存里是否有DNS记录。Windows系统中可以通过C:\Windows\System32\drivers\etc\hosts文件来设置，linux上配置文件是/etc/named.conf。 路由器缓存：如果本地系统缓存也未找到，前面的查询请求发向路由器，路由器也会有自己的DNS缓存记录。 ISP DNS缓存：接下来要检查的就是网络服务提供商缓存DNS的服务器，在这一般都能找到相应的缓存记录。ISP专门的域名解析服务器（LDNS）一般都会缓存域名解析记录，缓存时间受域名的失效时间控制，大约80%的域名解析到这里就已经完成了，所以，LDNS主要承担了域名的解析工作。 递归搜索：从根域名服务器开始进行递归搜索，到顶级域名服务器，再到第二层域服务器。 域名解析示意图 前面浏览器缓存，系统缓存及路由器缓存都是在本地完成的，所以，图中所示是从本地区的域名服务器LDNS开始的。我们在网络配置中，都会有一个“DNS服务器地址”这一项，这个地址就是本地区域名服务器LDNS。这个DNS服务器通常是由提供给你网络服务的提供商提供，如联通或电信等。如图中第三步，用户发起请求向LDNS查询，LDNS会查询其服务器上的缓存记录，如果有，返回，没有，继续。如果LDNS没有查找到缓存记录，就直接到Root Server域名服务器请求解析。根域名服务器返回给本地域名服务器一个所查询的主域名服务器(gTLD Server)地址，gTLD是国际顶级域名服务器，如.com,.cn,.org等，全球只有13台根域名服务器。LDNS再向上一步返回的gTLD服务器发送请求。gTLD服务器查找并返回此域名对应的Name Server域名服务器的地址。Name Server域名服务器会查询存储的域名和IP映射关系表，将ip连同一个TTL值返回给LDNS域名服务器LDNS域名服务器会缓存这个域名和ip的对应关系，并将结果返回给用户。用户本地根据TTL值缓存在本地系统中。在实际DNS解析过程中，Name Server也可能有很多级，或者有一个GTM负载均衡控制，这都有可能会影响到域名解析过程。 解析 www.163.com示例 hexo绑定域名过程阿里云DNS解析在阿里云解析域名的时候还遇到了小问题呢，一一记录下，也算是学习过程吧。 CNAME的@记录和MX的@记录不能共存由于我的域名coolcao.com开通的时候，自动开通了企业邮箱，因此，在域名解析那里，阿里云自动生成了几条和邮件相关的解析记录，如下图：从上图中可以看出，由于开通了企业邮箱，默认开启5条记录，两条不同优先级的MX记录，三条CNAME记录，当我添加解析到我的github pages的记录时报错了：点开冲突记录规则，有如下规则：也就是说，MX记录和CNAME在主机记录为 @时不能共存，那该怎么办，企业邮箱和www站不能同时解析拥有么？当然不是，经过上网查找资料，大致有下面两个办法： 采用Link类型解析首先添加一条CNAME类型的www记录，解析到github pages地址。然后再添加一条Link类型的@解析，这里解析到带www的完整地址，这里我的是：www.coolcao.com但这里有个要求，是域名必须要经过备案，即coolcao.com要必须备案，才能添加。由于我的还未备案，无从验证实验结果。如果有备案的，可以验证一下是否有效。 采用A类型解析我的域名没有备案，因此用不了Link类型，可以采用A类型解析。首先使用ping命令看一下自己的github pages的IP是多少。我这里查到的是：151.101.100.133,因此添加如下记录：同时添加一条CNAME类型的www解析，这样，可以通过coolcao.com或www.coolcao.com都能访问到我的小站。但这种方式也有个问题，如果github的IP地址变化了的话，得需要再改变A记录的值，可以说是一种不稳定的因素吧。但是域名没备案，没办法的办法。 github pages项目下为什么还要添加CNAME文件最开始，在设置未开通邮箱服务的愉快绑定时，很简单，直接添加了两条CNAME记录，一条@，一条www两条均解析到了coolcao.github.io那时候还一直在想，为什么要在项目里添加CNAME文件呢？我直接访问coolcao.github.io直接访问到我的github pages主页，那么，我将我的域名coolcao.com通过CNAME解析到coolcao.github.io不就可以了么，但是结果却是，github提示找不到页面。当资料整理到这里，我才慢慢理解了原因：所有的DNS解析最终都是将域名解析成IP，如果直接使用A记录直接解析到github的ip的话，在github上有成千上万的pages项目，那么，当你输入coolcao.com时，github怎么知道你的项目在哪里呢？这就是项目里CNAME文件的用处，把你的域名和项目进行绑定，当你访问coolcao.com，DNS解析到github的IP时，由于请求头中会带有coolcao.com，github通过CNAME的绑定，查询到了你具体的项目，才能正确找到你的项目。]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>DNS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小白git教程]]></title>
    <url>%2F2018%2F09%2F13%2F%E5%B0%8F%E7%99%BDgit%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[史上最浅显易懂的Git教程 这篇文章转载和整理自「原文」。 关于作者廖雪峰 Git简介Git是什么？ Git是目前世界上最先进的分布式版本控制系统（没有之一）。 Git有什么特点？简单来说就是：高端大气上档次！ 那什么是版本控制系统？ 如果你用Microsoft Word写过长篇大论，那你一定有这样的经历： 想删除一个段落，又怕将来想恢复找不回来怎么办？有办法，先把当前文件“另存为……”一个新的Word文件，再接着改，改到一定程度，再“另存为……”一个新文件，这样一直改下去，最后你的Word文档变成了这样： 过了一周，你想找回被删除的文字，但是已经记不清删除前保存在哪个文件里了，只好一个一个文件去找，真麻烦。 看着一堆乱七八糟的文件，想保留最新的一个，然后把其他的删掉，又怕哪天会用上，还不敢删，真郁闷。 更要命的是，有些部分需要你的财务同事帮助填写，于是你把文件Copy到U盘里给她（也可能通过Email发送一份给她），然后，你继续修改Word文件。一天后，同事再把Word文件传给你，此时，你必须想想，发给她之后到你收到她的文件期间，你作了哪些改动，得把你的改动和她的部分合并，真困难。 于是你想，如果有一个软件，不但能自动帮我记录每次文件的改动，还可以让同事协作编辑，这样就不用自己管理一堆类似的文件了，也不需要把文件传来传去。如果想查看某次改动，只需要在软件里瞄一眼就可以，岂不是很方便？ 这个软件用起来就应该像这个样子，能记录每次文件的改动： 版本 用户 说明 日期 1 张三 删除了软件服务条款5 7/12 10:38 2 张三 增加了License人数限制 7/12 18:09 3 李四 财务部门调整了合同金额 7/13 9:51 4 张三 延长了免费升级周期 7/14 15:17 这样，你就结束了手动管理多个“版本”的史前时代，进入到版本控制的20世纪。 Git的诞生很多人都知道，Linus在1991年创建了开源的Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。 Linus虽然创建了Linux，但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？ 事实是，在2002年以前，世界各地的志愿者把源代码文件通过diff的方式发给Linus，然后由Linus本人通过手工方式合并代码！ 你也许会想，为什么Linus不把Linux代码放到版本控制系统里呢？不是有CVS、SVN这些免费的版本控制系统吗？因为Linus坚定地反对CVS和SVN，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比CVS、SVN好用，但那是付费的，和Linux的开源精神不符。 不过，到了2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。 安定团结的大好局面在2005年就被打破了，原因是Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个），被BitMover公司发现了（监控工作做得不错！），于是BitMover公司怒了，要收回Linux社区的免费使用权。 Linus可以向BitMover公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是这样的： Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！牛是怎么定义的呢？大家可以体会一下。 Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。 历史就是这么偶然，如果不是当年BitMover公司威胁Linux社区，可能现在我们就没有免费而超级好用的Git了。 集中式vs分布式Linus一直痛恨的CVS及SVN都是集中式的版本控制系统，而Git是分布式版本控制系统，集中式和分布式版本控制系统有什么区别呢？ 先说集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。 集中式版本控制系统最大的毛病就是必须联网才能工作，如果在局域网内还好，带宽够大，速度够快，可如果在互联网上，遇到网速慢的话，可能提交一个10M的文件就需要5分钟，这还不得把人给憋死啊。 那分布式版本控制系统与集中式版本控制系统有何不同呢？首先，分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。 和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。 在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了，也可能今天你的同事病了，他的电脑压根没有开机。因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。 当然，Git的优势不单是不必联网这么简单，后面我们还会看到Git极其强大的分支管理，把SVN等远远抛在了后面。 CVS作为最早的开源而且免费的集中式版本控制系统，直到现在还有不少人在用。由于CVS自身设计的问题，会造成提交文件不完整，版本库莫名其妙损坏的情况。同样是开源而且免费的SVN修正了CVS的一些稳定性问题，是目前用得最多的集中式版本库控制系统。 除了免费的外，还有收费的集中式版本控制系统，比如IBM的ClearCase（以前是Rational公司的，被IBM收购了），特点是安装比Windows还大，运行比蜗牛还慢，能用ClearCase的一般是世界500强，他们有个共同的特点是财大气粗，或者人傻钱多。 微软自己也有一个集中式版本控制系统叫VSS，集成在Visual Studio中。由于其反人类的设计，连微软自己都不好意思用了。 分布式版本控制系统除了Git以及促使Git诞生的BitKeeper外，还有类似Git的Mercurial和Bazaar等。这些分布式版本控制系统各有特点，但最快、最简单也最流行的依然是Git！ 安装Git最早Git是在Linux上开发的，很长一段时间内，Git也只能在Linux和Unix系统上跑。不过，慢慢地有人把它移植到了Windows上。现在，Git可以在Linux、Unix、Mac和Windows这几大平台上正常运行了。 要使用Git，第一步当然是安装Git了。根据你当前使用的平台来阅读下面的文字： 在Linux上安装Git首先，你可以试着输入git，看看系统有没有安装Git： $ git The program &apos;git&apos; is currently not installed. You can install it by typing: sudo apt-get install git 像上面的命令，有很多Linux会友好地告诉你Git没有安装，还会告诉你如何安装Git。 如果你碰巧用Debian或Ubuntu Linux，通过一条sudo apt-get install git就可以直接完成Git的安装，非常简单。 老一点的Debian或Ubuntu Linux，要把命令改为sudo apt-get install git-core，因为以前有个软件也叫GIT（GNU Interactive Tools），结果Git就只能叫git-core了。由于Git名气实在太大，后来就把GNU Interactive Tools改成gnuit，git-core正式改为git。 如果是其他Linux版本，可以直接通过源码安装。先从Git官网下载源码，然后解压，依次输入：./config，make，sudo make install这几个命令安装就好了。 在Mac OS X上安装Git如果你正在使用Mac做开发，有两种安装Git的方法。 一是安装homebrew，然后通过homebrew安装Git，具体方法请参考homebrew的文档：http://brew.sh/。 第二种方法更简单，也是推荐的方法，就是直接从AppStore安装Xcode，Xcode集成了Git，不过默认没有安装，你需要运行Xcode，选择菜单“Xcode”-&gt;“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”就可以完成安装了。 Xcode是Apple官方IDE，功能非常强大，是开发Mac和iOS App的必选装备，而且是免费的！ 在Windows上安装Git实话实说，Windows是最烂的开发平台，如果不是开发Windows游戏或者在IE里调试页面，一般不推荐用Windows。不过，既然已经上了微软的贼船，也是有办法安装Git的。 Windows下要使用很多Linux/Unix的工具时，需要Cygwin这样的模拟环境，Git也一样。Cygwin的安装和配置都比较复杂，就不建议你折腾了。不过，有高人已经把模拟环境和Git都打包好了，名叫msysgit，只需要下载一个单独的exe安装程序，其他什么也不用装，绝对好用。 msysgit是Windows版的Git，从http://msysgit.github.io/下载，然后按默认选项安装即可。 安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！ 安装完成后，还需要最后一步设置，在命令行输入： $ git config --global user.name &quot;Your Name&quot; $ git config --global user.email &quot;email@example.com&quot; 因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。你也许会担心，如果有人故意冒充别人怎么办？这个不必担心，首先我们相信大家都是善良无知的群众，其次，真的有冒充的也是有办法可查的。 注意git config命令的--global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。 创建版本库什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。 所以，创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录： $ mkdir learngit $ cd learngit $ pwd /Users/michael/learngit pwd命令用于显示当前目录。在我的Mac上，这个仓库位于/Users/michael/learngit。 如果你使用Windows系统，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文。 第二步，通过git init命令把这个目录变成Git可以管理的仓库： $ git init Initialized empty Git repository in /Users/michael/learngit/.git/ 瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。 如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。 也不一定必须在空目录下创建Git仓库，选择一个已经有东西的目录也是可以的。不过，不建议你使用自己正在开发的公司项目来学习Git，否则造成的一切后果概不负责。 把文件添加到版本库首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。 不幸的是，Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的，前面我们举的例子只是为了演示，如果要真正使用版本控制系统，就要以纯文本方式编写文件。 因为文本是有编码的，比如中文有常用的GBK编码，日文有Shift_JIS编码，如果没有历史遗留问题，强烈建议使用标准的UTF-8编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。 使用Windows的童鞋要特别注意： 千万不要使用Windows自带的记事本编辑任何文本文件。原因是Microsoft开发记事本的团队使用了一个非常弱智的行为来保存UTF-8编码的文件，他们自作聪明地在每个文件开头添加了0xefbbbf（十六进制）的字符，你会遇到很多不可思议的问题，比如，网页第一行可能会显示一个“?”，明明正确的程序一编译就报语法错误，等等，都是由记事本的弱智行为带来的。建议你下载Notepad++代替记事本，不但功能强大，而且免费！记得把Notepad++的默认编码设置为UTF-8 without BOM即可： 言归正传，现在我们编写一个readme.txt文件，内容如下： Git is a version control system. Git is free software. 一定要放到learngit目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。 和把大象放到冰箱需要3步相比，把一个文件放到Git仓库只需要两步。 第一步，用命令git add告诉Git，把文件添加到仓库： $ git add readme.txt 执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。 第二步，用命令git commit告诉Git，把文件提交到仓库： $ git commit -m &quot;wrote a readme file&quot; [master (root-commit) cb926e7] wrote a readme file 1 file changed, 2 insertions(+) create mode 100644 readme.txt 简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。 嫌麻烦不想输入-m &quot;xxx&quot;行不行？确实有办法可以这么干，但是强烈不建议你这么干，因为输入说明对自己对别人阅读都很重要。实在不想输入说明的童鞋请自行Google，我不告诉你这个参数。 git commit命令执行成功后会告诉你，1个文件被改动（我们新添加的readme.txt文件），插入了两行内容（readme.txt有两行内容）。 为什么Git添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如： $ git add file1.txt $ git add file2.txt file3.txt $ git commit -m &quot;add 3 files.&quot; 小结 现在总结一下今天学的两点内容： 初始化一个Git仓库，使用git init命令。 添加文件到Git仓库，分两步： 第一步，使用命令git add，注意，可反复多次使用，添加多个文件； 第二步，使用命令git commit，完成。 时光机穿梭我们已经成功地添加并提交了一个readme.txt文件，现在，是时候继续工作了，于是，我们继续修改readme.txt文件，改成如下内容： Git is a distributed version control system. Git is free software. 现在，运行git status命令看看结果： $ git status # On branch master # Changes not staged for commit: # (use “git add …” to update what will be committed) # (use “git checkout – …” to discard changes in working directory) # # modified: readme.txt # no changes added to commit (use “git add” and/or “git commit -a”) git status命令可以让我们时刻掌握仓库当前的状态，上面的命令告诉我们，readme.txt被修改过了，但还没有准备提交的修改。 虽然Git告诉我们readme.txt被修改了，但如果能看看具体修改了什么内容，自然是很好的。比如你休假两周从国外回来，第一天上班时，已经记不清上次怎么修改的readme.txt，所以，需要用git diff这个命令看看： $ git diff readme.txt diff –git a/readme.txt b/readme.txt index 46d49bf..9247db6 100644 --- a/readme.txt +++ b/readme.txt @@ -1,2 +1,2 @@ -Git is a version control system. +Git is a distributed version control system. Git is free software. git diff顾名思义就是查看difference，显示的格式正是Unix通用的diff格式，可以从上面的命令输出看到，我们在第一行添加了一个“distributed”单词。 知道了对readme.txt作了什么修改后，再把它提交到仓库就放心多了，提交修改和提交新文件是一样的两步，第一步是git add： $ git add readme.txt 同样没有任何输出。在执行第二步git commit之前，我们再运行git status看看当前仓库的状态： $ git status # On branch master # Changes to be committed: # (use “git reset HEAD …” to unstage) # # modified: readme.txt # git status告诉我们，将要被提交的修改包括readme.txt，下一步，就可以放心地提交了： $ git commit -m “add distributed” [master ea34578] add distributed 1 file changed, 1 insertion(+), 1 deletion(-) 提交后，我们再用git status命令看看仓库的当前状态： $ git status # On branch master nothing to commit (working directory clean) Git告诉我们当前没有需要提交的修改，而且，工作目录是干净（working directory clean）的。 小结 要随时掌握工作区的状态，使用git status命令。 如果git status告诉你有文件被修改过，用git diff可以查看修改内容。 版本回退现在，你已经学会了修改文件，然后把修改提交到Git版本库，现在，再练习一次，修改readme.txt文件如下： Git is a distributed version control system. Git is free software distributed under the GPL. 然后尝试提交： $ git add readme.txt $ git commit -m “append GPL” [master 3628164] append GPL 1 file changed, 1 insertion(+), 1 deletion(-) 像这样，你不断对文件进行修改，然后不断提交修改到版本库里，就好比玩RPG游戏时，每通过一关就会自动把游戏状态存盘，如果某一关没过去，你还可以选择读取前一关的状态。有些时候，在打Boss之前，你会手动存盘，以便万一打Boss失败了，可以从最近的地方重新开始。Git也是一样，每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为commit。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个commit恢复，然后继续工作，而不是把几个月的工作成果全部丢失。 现在，我们回顾一下readme.txt文件一共有几个版本被提交到Git仓库里了： 版本1：wrote a readme file Git is a version control system. Git is free software. 版本2：add distributed Git is a distributed version control system. Git is free software. 版本3：append GPL Git is a distributed version control system. Git is free software distributed under the GPL. 当然了，在实际工作中，我们脑子里怎么可能记得一个几千行的文件每次都改了什么内容，不然要版本控制系统干什么。版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用git log命令查看： $ git log commit 3628164fb26d48395383f8f31179f24e0882e1e0 Author: Michael Liao &#x61;&#115;&#x6b;&#x78;&#117;&#101;&#102;&#101;&#110;&#x67;&#x40;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109; Date: Tue Aug 20 15:11:49 2013 +0800 append GPL commit ea34578d5496d7dd233c827ed32a8cd576c5ee85 Author: Michael Liao &#97;&#115;&#x6b;&#x78;&#x75;&#101;&#102;&#x65;&#x6e;&#103;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d; Date: Tue Aug 20 14:53:12 2013 +0800 add distributed commit cb926e7ea50ad11b8f9e909c05226233bf755030 Author: Michael Liao &#97;&#115;&#x6b;&#120;&#117;&#x65;&#102;&#x65;&#x6e;&#103;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#99;&#111;&#x6d; Date: Mon Aug 19 17:51:55 2013 +0800 wrote a readme file git log命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是append GPL，上一次是add distributed，最早的一次是wrote a readme file。如果嫌输出信息太多，看得眼花缭乱的，可以试试加上--pretty=oneline参数： $ git log –pretty=oneline 3628164fb26d48395383f8f31179f24e0882e1e0 append GPL ea34578d5496d7dd233c827ed32a8cd576c5ee85 add distributed cb926e7ea50ad11b8f9e909c05226233bf755030 wrote a readme file 需要友情提示的是，你看到的一大串类似3628164...882e1e0的是commit id（版本号），和SVN不一样，Git的commit id不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的commit id和我的肯定不一样，以你自己的为准。为什么commit id需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。 每提交一个新版本，实际上Git就会把它们自动串成一条时间线。如果使用可视化工具查看Git历史，就可以更清楚地看到提交历史的时间线： 好了，现在我们启动时光穿梭机，准备把readme.txt回退到上一个版本，也就是“add distributed”的那个版本，怎么做呢？ 首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交3628164...882e1e0（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。 现在，我们要把当前版本“append GPL”回退到上一个版本“add distributed”，就可以使用git reset命令： $ git reset –hard HEAD^ HEAD is now at ea34578 add distributed --hard参数有啥意义？这个后面再讲，现在你先放心使用。 看看readme.txt的内容是不是版本add distributed： $ cat readme.txt Git is a distributed version control system. Git is free software. 果然。 还可以继续回退到上一个版本wrote a readme file，不过且慢，然我们用git log再看看现在版本库的状态： $ git log commit ea34578d5496d7dd233c827ed32a8cd576c5ee85 Author: Michael Liao &#97;&#115;&#107;&#120;&#117;&#x65;&#x66;&#101;&#110;&#x67;&#x40;&#103;&#109;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d; Date: Tue Aug 20 14:53:12 2013 +0800 add distributed commit cb926e7ea50ad11b8f9e909c05226233bf755030 Author: Michael Liao &#x61;&#115;&#107;&#120;&#117;&#101;&#102;&#x65;&#x6e;&#103;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#109; Date: Mon Aug 19 17:51:55 2013 +0800 wrote a readme file 最新的那个版本append GPL已经看不到了！好比你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，肿么办？ 办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个append GPL的commit id是3628164...，于是就可以指定回到未来的某个版本： $ git reset –hard 3628164 HEAD is now at 3628164 append GPL 版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。 再小心翼翼地看看readme.txt的内容： $ cat readme.txt Git is a distributed version control system. Git is free software distributed under the GPL. 果然，我胡汉三又回来了。 Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD从指向append GPL： 改为指向add distributed： 然后顺便把工作区的文件更新了。所以你让HEAD指向哪个版本号，你就把当前版本定位在哪。 现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？ 在Git中，总是有后悔药可以吃的。当你用$ git reset --hard HEAD^回退到add distributed版本时，再想恢复到append GPL，就必须找到append GPL的commit id。Git提供了一个命令git reflog用来记录你的每一次命令： $ git reflog ea34578 HEAD@{0}: reset: moving to HEAD^ 3628164 HEAD@{1}: commit: append GPL ea34578 HEAD@{2}: commit: add distributed cb926e7 HEAD@{3}: commit (initial): wrote a readme file 终于舒了口气，第二行显示append GPL的commit id是3628164，现在，你又可以乘坐时光机回到未来了。 小结 现在总结一下： HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。 穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。 工作区和暂存区Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。 先来看名词解释。 工作区（Working Directory）就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区： 版本库（Repository）工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。 Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。 分支和HEAD的概念我们以后再讲。 前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的： 第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区； 第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。 因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。 你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。 俗话说，实践出真知。现在，我们再练习一遍，先对readme.txt做个修改，比如加上一行内容： Git is a distributed version control system. Git is free software distributed under the GPL. Git has a mutable index called stage. 然后，在工作区新增一个LICENSE文本文件（内容随便写）。 先用git status查看一下状态： $ git status # On branch master # Changes not staged for commit: # (use “git add …” to update what will be committed) # (use “git checkout – …” to discard changes in working directory) # # modified: readme.txt # # Untracked files: # (use “git add …” to include in what will be committed) # # LICENSE no changes added to commit (use “git add” and/or “git commit -a”) Git非常清楚地告诉我们，readme.txt被修改了，而LICENSE还从来没有被添加过，所以它的状态是Untracked。 现在，使用两次命令git add，把readme.txt和LICENSE都添加后，用git status再查看一下： $ git status # On branch master # Changes to be committed: # (use “git reset HEAD …” to unstage) # # new file: LICENSE # modified: readme.txt # 现在，暂存区的状态就变成这样了： 所以，git add命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行git commit就可以一次性把暂存区的所有修改提交到分支。 $ git commit -m “understand how stage works” [master 27c9860] understand how stage works 2 files changed, 675 insertions(+) create mode 100644 LICENSE 一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的： $ git status # On branch master nothing to commit (working directory clean) 现在版本库变成了这样，暂存区就没有任何内容了： 小结 暂存区是Git非常重要的概念，弄明白了暂存区，就弄明白了Git的很多操作到底干了什么。 没弄明白暂存区是怎么回事的童鞋，请向上滚动页面，再看一次。 管理修改现在，假定你已经完全掌握了暂存区的概念。下面，我们要讨论的就是，为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。 你会问，什么是修改？比如你新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。 为什么说Git管理的是修改，而不是文件呢？我们还是做实验。第一步，对readme.txt做一个修改，比如加一行内容： $ cat readme.txt Git is a distributed version control system. Git is free software distributed under the GPL. Git has a mutable index called stage. Git tracks changes. 然后，添加： $ git add readme.txt $ git status # On branch master # Changes to be committed: # (use “git reset HEAD …” to unstage) # # modified: readme.txt # 然后，再修改readme.txt： $ cat readme.txt Git is a distributed version control system. Git is free software distributed under the GPL. Git has a mutable index called stage. Git tracks changes of files. 提交： $ git commit -m “git tracks changes” [master d4f25b6] git tracks changes 1 file changed, 1 insertion(+) 提交后，再看看状态： $ git status # On branch master # Changes not staged for commit: # (use “git add …” to update what will be committed) # (use “git checkout – …” to discard changes in working directory) # # modified: readme.txt # no changes added to commit (use “git add” and/or “git commit -a”) 咦，怎么第二次的修改没有被提交？ 别激动，我们回顾一下操作过程： 第一次修改 -> git add -&gt; 第二次修改 -> git commit 你看，我们前面讲了，Git管理的是修改，当你用git add命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，git commit只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。 提交后，用git diff HEAD -- readme.txt命令可以查看工作区和版本库里面最新版本的区别： $ git diff HEAD – readme.txt diff –git a/readme.txt b/readme.txt index 76d770f..a9c5755 100644 --- a/readme.txt +++ b/readme.txt @@ -1,4 +1,4 @@ Git is a distributed version control system. Git is free software distributed under the GPL. Git has a mutable index called stage. -Git tracks changes. +Git tracks changes of files. 可见，第二次修改确实没有被提交。 那怎么提交第二次修改呢？你可以继续git add再git commit，也可以别着急提交第一次修改，先git add第二次修改，再git commit，就相当于把两次修改合并后一块提交了： 第一次修改 -> git add -&gt; 第二次修改 -> git add -> git commit 好，现在，把第二次修改提交了，然后开始小结。 小结 现在，你又理解了Git是如何跟踪修改的，每次修改，如果不add到暂存区，那就不会加入到commit中。 撤销修改自然，你是不会犯错的。不过现在是凌晨两点，你正在赶一份工作报告，你在readme.txt中添加了一行： $ cat readme.txt Git is a distributed version control system. Git is free software distributed under the GPL. Git has a mutable index called stage. Git tracks changes of files. My stupid boss still prefers SVN. 在你准备提交前，一杯咖啡起了作用，你猛然发现了“stupid boss”可能会让你丢掉这个月的奖金！ 既然错误发现得很及时，就可以很容易地纠正它。你可以删掉最后一行，手动把文件恢复到上一个版本的状态。如果用git status查看一下： $ git status # On branch master # Changes not staged for commit: # (use “git add …” to update what will be committed) # (use “git checkout – …” to discard changes in working directory) # # modified: readme.txt # no changes added to commit (use “git add” and/or “git commit -a”) 你可以发现，Git会告诉你，git checkout -- file可以丢弃工作区的修改： $ git checkout -- readme.txt 命令git checkout -- readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况： 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 总之，就是让这个文件回到最近一次git commit或git add时的状态。 现在，看看readme.txt的文件内容： $ cat readme.txt Git is a distributed version control system. Git is free software distributed under the GPL. Git has a mutable index called stage. Git tracks changes of files. 文件内容果然复原了。 git checkout -- file命令中的--很重要，没有--，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到git checkout命令。 现在假定是凌晨3点，你不但写了一些胡话，还git add到暂存区了： $ cat readme.txt Git is a distributed version control system. Git is free software distributed under the GPL. Git has a mutable index called stage. Git tracks changes of files. My stupid boss still prefers SVN. $ git add readme.txt 庆幸的是，在commit之前，你发现了这个问题。用git status查看一下，修改只是添加到了暂存区，还没有提交： $ git status # On branch master # Changes to be committed: # (use “git reset HEAD …” to unstage) # # modified: readme.txt # Git同样告诉我们，用命令git reset HEAD file可以把暂存区的修改撤销掉（unstage），重新放回工作区： $ git reset HEAD readme.txt Unstaged changes after reset: M readme.txt git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。 再用git status查看一下，现在暂存区是干净的，工作区有修改： $ git status # On branch master # Changes not staged for commit: # (use “git add …” to update what will be committed) # (use “git checkout – …” to discard changes in working directory) # # modified: readme.txt # no changes added to commit (use “git add” and/or “git commit -a”) 还记得如何丢弃工作区的修改吗？ $ git checkout -- readme.txt $ git status # On branch master nothing to commit (working directory clean) 整个世界终于清静了！ 现在，假设你不但改错了东西，还从暂存区提交到了版本库，怎么办呢？还记得版本回退一节吗？可以回退到上一个版本。不过，这是有条件的，就是你还没有把自己的本地版本库推送到远程。还记得Git是分布式版本控制系统吗？我们后面会讲到远程版本库，一旦你把“stupid boss”提交推送到远程版本库，你就真的惨了…… 小结 又到了小结时间。 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作。 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。 删除文件在Git中，删除也是一个修改操作，我们实战一下，先添加一个新文件test.txt到Git并且提交： $ git add test.txt $ git commit -m “add test.txt” [master 94cdc44] add test.txt 1 file changed, 1 insertion(+) create mode 100644 test.txt 一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了： $ rm test.txt 这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了： $ git status # On branch master # Changes not staged for commit: # (use “git add/rm …” to update what will be committed) # (use “git checkout – …” to discard changes in working directory) # # deleted: test.txt # no changes added to commit (use “git add” and/or “git commit -a”) 现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit： $ git rm test.txt rm ‘test.txt’ $ git commit -m “remove test.txt” [master d17efd8] remove test.txt 1 file changed, 1 deletion(-) delete mode 100644 test.txt 现在，文件就从版本库中被删除了。 另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本： $ git checkout -- test.txt git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。 小结 命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。 远程仓库到目前为止，我们已经掌握了如何在Git仓库里对一个文件进行时光穿梭，你再也不用担心文件备份或者丢失的问题了。 可是有用过集中式版本控制系统SVN的童鞋会站出来说，这些功能在SVN里早就有了，没看出Git有什么特别的地方。 没错，如果只是在一个仓库里管理文件历史，Git和SVN真没啥区别。为了保证你现在所学的Git物超所值，将来绝对不会后悔，同时为了打击已经不幸学了SVN的童鞋，本章开始介绍Git的杀手级功能之一（注意是之一，也就是后面还有之二，之三……）：远程仓库。 Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。怎么分布呢？最早，肯定只有一台机器有一个原始版本库，此后，别的机器可以“克隆”这个原始版本库，而且每台机器的版本库其实都是一样的，并没有主次之分。 你肯定会想，至少需要两台机器才能玩远程库不是？但是我只有一台电脑，怎么玩？ 其实一台电脑上也是可以克隆多个版本库的，只要不在同一个目录下。不过，现实生活中是不会有人这么傻的在一台电脑上搞几个远程库玩，因为一台电脑上搞几个远程库完全没有意义，而且硬盘挂了会导致所有库都挂掉，所以我也不告诉你在一台电脑上怎么克隆多个仓库。 实际情况往往是这样，找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。 完全可以自己搭建一台运行Git的服务器，不过现阶段，为了学Git先搭个服务器绝对是小题大作。好在这个世界上有个叫GitHub的神奇的网站，从名字就可以看出，这个网站就是提供Git仓库托管服务的，所以，只要注册一个GitHub账号，就可以免费获得Git远程仓库。 在继续阅读后续内容前，请自行注册GitHub账号。由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置： 第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key： $ ssh-keygen -t rsa -C “youremail@example.com“ 你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。 如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。 第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面： 然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容： 点“Add Key”，你就应该看到已经添加的Key： 为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。 当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。 最后友情提示，在GitHub上免费托管的Git仓库，任何人都可以看到喔（但只有你自己才能改）。所以，不要把敏感信息放进去。 如果你不想让别人看到Git库，有两个办法，一个是交点保护费，让GitHub把公开的仓库变成私有的，这样别人就看不见了（不可读更不可写）。另一个办法是自己动手，搭一个Git服务器，因为是你自己的Git服务器，所以别人也是看不见的。这个方法我们后面会讲到的，相当简单，公司内部开发必备。 确保你拥有一个GitHub账号后，我们就即将开始远程仓库的学习。 小结 “有了远程仓库，妈妈再也不用担心我的硬盘了。”——Git点读机 添加远程库现在的情景是，你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。 首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库： 在Repository name填入learngit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库： 目前，在GitHub上的这个learngit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。 现在，我们根据GitHub的提示，在本地的learngit仓库下运行命令： $ git remote add origin git@github.com:michaelliao/learngit.git 请千万注意，把上面的michaelliao替换成你自己的GitHub账户名，否则，你在本地关联的就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。 添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。 下一步，就可以把本地库的所有内容推送到远程库上： $ git push -u origin master Counting objects: 19, done. Delta compression using up to 4 threads. Compressing objects: 100% (19/19), done. Writing objects: 100% (19/19), 13.73 KiB, done. Total 23 (delta 6), reused 0 (delta 0) To git@github.com:michaelliao/learngit.git * [new branch] master -> master Branch master set up to track remote branch master from origin. 把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样： 从现在起，只要本地作了提交，就可以通过命令： $ git push origin master 把本地master分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！ SSH警告当你第一次使用Git的clone或者push命令连接GitHub时，会得到一个警告： The authenticity of host ‘github.com (xx.xx.xx.xx)’ can’t be established. RSA key fingerprint is xx.xx.xx.xx.xx. Are you sure you want to continue connecting (yes/no)? 这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入yes回车即可。 Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了： Warning: Permanently added ‘github.com’ (RSA) to the list of known hosts. 这个警告只会出现一次，后面的操作就不会有任何警告了。 如果你实在担心有人冒充GitHub服务器，输入yes前可以对照GitHub的RSA Key的指纹信息是否与SSH连接给出的一致。 小结 要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git； 关联后，使用命令git push -u origin master第一次推送master分支的所有内容； 此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改； 分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！ 从远程库克隆上次我们讲了先有本地库，后有远程库的时候，如何关联远程库。 现在，假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。 首先，登陆GitHub，创建一个新的仓库，名字叫gitskills： 我们勾选Initialize this repository with a README，这样GitHub会自动为我们创建一个README.md文件。创建完毕后，可以看到README.md文件： 现在，远程库已经准备好了，下一步是用命令git clone克隆一个本地库： $ git clone git@github.com:michaelliao/gitskills.git Cloning into ‘gitskills’… remote: Counting objects: 3, done. remote: Total 3 (delta 0), reused 0 (delta 0) Receiving objects: 100% (3/3), done. $ cd gitskills $ ls README.md 注意把Git库的地址换成你自己的，然后进入gitskills目录看看，已经有README.md文件了。 如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。 你也许还注意到，GitHub给出的地址不止一个，还可以用https://github.com/michaelliao/gitskills.git这样的地址。实际上，Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。 使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https。 小结 要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆。 Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。 分支管理分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。 如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，你既学会了Git又学会了SVN！ 分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。 现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。 其他版本控制系统如SVN等都有分支管理，但是用过之后你会发现，这些版本控制系统创建和切换分支比蜗牛还慢，简直让人无法忍受，结果分支功能成了摆设，大家都不去用。 但Git的分支是与众不同的，无论创建、切换和删除分支，Git在1秒钟之内就能完成！无论你的版本库是1个文件还是1万个文件。 创建与合并分支在版本回退里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。 一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点： 每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长： 当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上： 你看，Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！ 不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变： 假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并： 所以Git合并分支也很快！就改改指针，工作区内容也不变！ 合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支： 真是太神奇了，你看得出来有些提交是通过分支完成的吗？ 下面开始实战。 首先，我们创建dev分支，然后切换到dev分支： $ git checkout -b dev Switched to a new branch ‘dev’ git checkout命令加上-b参数表示创建并切换，相当于以下两条命令： $ git branch dev $ git checkout dev Switched to branch ‘dev’ 然后，用git branch命令查看当前分支： $ git branch * dev master git branch命令会列出所有分支，当前分支前面会标一个*号。 然后，我们就可以在dev分支上正常提交，比如对readme.txt做个修改，加上一行： Creating a new branch is quick. 然后提交： $ git add readme.txt $ git commit -m “branch test” [dev fec145a] branch test 1 file changed, 1 insertion(+) 现在，dev分支的工作完成，我们就可以切换回master分支： $ git checkout master Switched to branch ‘master’ 切换回master分支后，再查看一个readme.txt文件，刚才添加的内容不见了！因为那个提交是在dev分支上，而master分支此刻的提交点并没有变： 现在，我们把dev分支的工作成果合并到master分支上： $ git merge dev Updating d17efd8..fec145a Fast-forward readme.txt | 1 + 1 file changed, 1 insertion(+) git merge命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。 注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。 当然，也不是每次合并都能Fast-forward，我们后面会讲其他方式的合并。 合并完成后，就可以放心地删除dev分支了： $ git branch -d dev Deleted branch dev (was fec145a). 删除后，查看branch，就只剩下master分支了： $ git branch * master 因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。 小结 Git鼓励大量使用分支： 查看分支：git branch 创建分支：git branch 切换分支：git checkout 创建+切换分支：git checkout -b 合并某分支到当前分支：git merge 删除分支：git branch -d 解决冲突人生不如意之事十之八九，合并分支往往也不是一帆风顺的。 准备新的feature1分支，继续我们的新分支开发： $ git checkout -b feature1 Switched to a new branch ‘feature1’ 修改readme.txt最后一行，改为： Creating a new branch is quick AND simple. 在feature1分支上提交： $ git add readme.txt $ git commit -m “AND simple” [feature1 75a857c] AND simple 1 file changed, 1 insertion(+), 1 deletion(-) 切换到master分支： $ git checkout master Switched to branch ‘master’ Your branch is ahead of ‘origin/master’ by 1 commit. Git还会自动提示我们当前master分支比远程的master分支要超前1个提交。 在master分支上把readme.txt文件的最后一行改为： Creating a new branch is quick &amp; simple. 提交： $ git add readme.txt $ git commit -m “&amp; simple” [master 400b400] &amp; simple 1 file changed, 1 insertion(+), 1 deletion(-) 现在，master分支和feature1分支各自都分别有新的提交，变成了这样： 这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看： $ git merge feature1 Auto-merging readme.txt CONFLICT (content): Merge conflict in readme.txt Automatic merge failed; fix conflicts and then commit the result. 果然冲突了！Git告诉我们，readme.txt文件存在冲突，必须手动解决冲突后再提交。git status也可以告诉我们冲突的文件： $ git status # On branch master # Your branch is ahead of ‘origin/master’ by 2 commits. # # Unmerged paths: # (use “git add/rm …” as appropriate to mark resolution) # # both modified: readme.txt # no changes added to commit (use “git add” and/or “git commit -a”) 我们可以直接查看readme.txt的内容： Git is a distributed version control system. Git is free software distributed under the GPL. Git has a mutable index called stage. Git tracks changes of files. &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD Creating a new branch is quick &amp; simple. ======= Creating a new branch is quick AND simple. > feature1 Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，我们修改如下后保存： Creating a new branch is quick and simple. 再提交： $ git add readme.txt $ git commit -m “conflict fixed” [master 59bc1cb] conflict fixed 现在，master分支和feature1分支变成了下图所示： 用带参数的git log也可以看到分支的合并情况： $ git log –graph –pretty=oneline –abbrev-commit * 59bc1cb conflict fixed |\ | * 75a857c AND simple * | 400b400 &amp; simple |/ * fec145a branch test … 最后，删除feature1分支： $ git branch -d feature1 Deleted branch feature1 (was 75a857c). 工作完成。 小结 当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。 用git log --graph命令可以看到分支合并图。 分支管理策略通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。 如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。 下面我们实战一下--no-ff方式的git merge： 首先，仍然创建并切换dev分支： $ git checkout -b dev Switched to a new branch ‘dev’ 修改readme.txt文件，并提交一个新的commit： $ git add readme.txt $ git commit -m “add merge” [dev 6224937] add merge 1 file changed, 1 insertion(+) 现在，我们切换回master： $ git checkout master Switched to branch ‘master’ 准备合并dev分支，请注意--no-ff参数，表示禁用Fast forward： $ git merge –no-ff -m “merge with no-ff” dev Merge made by the ‘recursive’ strategy. readme.txt | 1 + 1 file changed, 1 insertion(+) 因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。 合并后，我们用git log看看分支历史： $ git log –graph –pretty=oneline –abbrev-commit * 7825a50 merge with no-ff |\ | * 6224937 add merge |/ * 59bc1cb conflict fixed … 可以看到，不使用Fast forward模式，merge后就像这样： 分支策略在实际开发中，我们应该按照几个基本原则进行分支管理： 首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活； 那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本； 你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。 所以，团队合作的分支看起来就像这样： 小结 Git分支十分强大，在团队开发中应该充分应用。 合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。 Bug分支软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。 当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它，但是，等等，当前正在dev上进行的工作还没有提交： $ git status # On branch dev # Changes to be committed: # (use “git reset HEAD …” to unstage) # # new file: hello.py # # Changes not staged for commit: # (use “git add …” to update what will be committed) # (use “git checkout – …” to discard changes in working directory) # # modified: readme.txt # 并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？ 幸好，Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作： $ git stash Saved working directory and index state WIP on dev: 6224937 add merge HEAD is now at 6224937 add merge 现在，用git status查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。 首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支： $ git checkout master Switched to branch ‘master’ Your branch is ahead of ‘origin/master’ by 6 commits. $ git checkout -b issue-101 Switched to a new branch ‘issue-101’ 现在修复bug，需要把“Git is free software …”改为“Git is a free software …”，然后提交： $ git add readme.txt $ git commit -m “fix bug 101” [issue-101 cc17032] fix bug 101 1 file changed, 1 insertion(+), 1 deletion(-) 修复完成后，切换到master分支，并完成合并，最后删除issue-101分支： $ git checkout master Switched to branch ‘master’ Your branch is ahead of ‘origin/master’ by 2 commits. $ git merge –no-ff -m “merged bug fix 101” issue-101 Merge made by the ‘recursive’ strategy. readme.txt | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-) $ git branch -d issue-101 Deleted branch issue-101 (was cc17032). 太棒了，原计划两个小时的bug修复只花了5分钟！现在，是时候接着回到dev分支干活了！ $ git checkout dev Switched to branch ‘dev’ $ git status # On branch dev nothing to commit (working directory clean) 工作区是干净的，刚才的工作现场存到哪去了？用git stash list命令看看： $ git stash list stash@{0}: WIP on dev: 6224937 add merge 工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法： 一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除； 另一种方式是用git stash pop，恢复的同时把stash内容也删了： $ git stash pop # On branch dev # Changes to be committed: # (use “git reset HEAD …” to unstage) # # new file: hello.py # # Changes not staged for commit: # (use “git add …” to update what will be committed) # (use “git checkout – …” to discard changes in working directory) # # modified: readme.txt # Dropped refs/stash@{0} (f624f8e5f082f2df2bed8a4e09c12fd2943bdd40) 再用git stash list查看，就看不到任何stash内容了： $ git stash list 你可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令： $ git stash apply stash@{0} 小结 修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除； 当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。 Feature分支软件开发中，总有无穷无尽的新的功能要不断添加进来。 添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。 现在，你终于接到了一个新任务：开发代号为Vulcan的新功能，该功能计划用于下一代星际飞船。 于是准备开发： $ git checkout -b feature-vulcan Switched to a new branch ‘feature-vulcan’ 5分钟后，开发完毕： $ git add vulcan.py $ git status # On branch feature-vulcan # Changes to be committed: # (use “git reset HEAD …” to unstage) # # new file: vulcan.py # $ git commit -m “add feature vulcan” [feature-vulcan 756d4af] add feature vulcan 1 file changed, 2 insertions(+) create mode 100644 vulcan.py 切回dev，准备合并： $ git checkout dev 一切顺利的话，feature分支和bug分支是类似的，合并，然后删除。 但是， 就在此时，接到上级命令，因经费不足，新功能必须取消！ 虽然白干了，但是这个分支还是必须就地销毁： $ git branch -d feature-vulcan error: The branch ‘feature-vulcan’ is not fully merged. If you are sure you want to delete it, run ‘git branch -D feature-vulcan’. 销毁失败。Git友情提醒，feature-vulcan分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用命令git branch -D feature-vulcan。 现在我们强行删除： $ git branch -D feature-vulcan Deleted branch feature-vulcan (was 756d4af). 终于删除成功！ 小结 开发一个新feature，最好新建一个分支； 如果要丢弃一个没有被合并过的分支，可以通过git branch -D强行删除。 多人协作当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。 要查看远程库的信息，用git remote： $ git remote origin 或者，用git remote -v显示更详细的信息： $ git remote -v origin git@github.com:michaelliao/learngit.git (fetch) origin git@github.com:michaelliao/learngit.git (push) 上面显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。 推送分支推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上： $ git push origin master 如果要推送其他分支，比如dev，就改成： $ git push origin dev 但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？ master分支是主分支，因此要时刻与远程同步； dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步； bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug； feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。 总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！ 抓取分支多人协作时，大家都会往master和dev分支上推送各自的修改。 现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆： $ git clone git@github.com:michaelliao/learngit.git Cloning into ‘learngit’… remote: Counting objects: 46, done. remote: Compressing objects: 100% (26/26), done. remote: Total 46 (delta 16), reused 45 (delta 15) Receiving objects: 100% (46/46), 15.69 KiB | 6 KiB/s, done. Resolving deltas: 100% (16/16), done. 当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的master分支。不信可以用git branch命令看看： $ git branch * master 现在，你的小伙伴要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支： $ git checkout -b dev origin/dev 现在，他就可以在dev上继续修改，然后，时不时地把dev分支push到远程： $ git commit -m “add /usr/bin/env” [dev 291bea8] add /usr/bin/env 1 file changed, 1 insertion(+) $ git push origin dev Counting objects: 5, done. Delta compression using up to 4 threads. Compressing objects: 100% (2/2), done. Writing objects: 100% (3/3), 349 bytes, done. Total 3 (delta 0), reused 0 (delta 0) To git@github.com:michaelliao/learngit.git fc38031..291bea8 dev -&gt; dev 你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送： $ git add hello.py $ git commit -m “add coding: utf-8” [dev bd6ae48] add coding: utf-8 1 file changed, 1 insertion(+) $ git push origin dev To git@github.com:michaelliao/learngit.git ! [rejected] dev -&gt; dev (non-fast-forward) error: failed to push some refs to &#39;git@github.com:michaelliao/learngit.git’ hint: Updates were rejected because the tip of your current branch is behind hint: its remote counterpart. Merge the remote changes (e.g. ‘git pull’) hint: before pushing again. hint: See the ‘Note about fast-forwards’ in ‘git push –help’ for details. 推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送： $ git pull remote: Counting objects: 5, done. remote: Compressing objects: 100% (2/2), done. remote: Total 3 (delta 0), reused 3 (delta 0) Unpacking objects: 100% (3/3), done. From github.com:michaelliao/learngit fc38031..291bea8 dev -&gt; origin/dev There is no tracking information for the current branch. Please specify which branch you want to merge with. See git-pull(1) for details git pull &lt;remote&gt; &lt;branch&gt; If you wish to set tracking information for this branch you can do so with: git branch --set-upstream dev origin/&lt;branch&gt; git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接： $ git branch –set-upstream dev origin/dev Branch dev set up to track remote branch dev from origin. 再pull： $ git pull Auto-merging hello.py CONFLICT (content): Merge conflict in hello.py Automatic merge failed; fix conflicts and then commit the result. 这回git pull成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样。解决后，提交，再push： $ git commit -m “merge &amp; fix hello.py” [dev adca45d] merge &amp; fix hello.py $ git push origin dev Counting objects: 10, done. Delta compression using up to 4 threads. Compressing objects: 100% (5/5), done. Writing objects: 100% (6/6), 747 bytes, done. Total 6 (delta 0), reused 0 (delta 0) To git@github.com:michaelliao/learngit.git 291bea8..adca45d dev -&gt; dev 因此，多人协作的工作模式通常是这样： 首先，可以试图用git push origin branch-name推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！ 如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream branch-name origin/branch-name。 这就是多人协作的工作模式，一旦熟悉了，就非常简单。 小结 查看远程库信息，使用git remote -v； 本地新建的分支如果不推送到远程，对其他人就是不可见的； 从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交； 在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致； 建立本地分支和远程分支的关联，使用git branch --set-upstream branch-name origin/branch-name； 从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。 标签管理发布一个版本时，我们通常先在版本库中打一个标签，这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。 Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。 创建标签在Git中打标签非常简单，首先，切换到需要打标签的分支上： $ git branch * dev master $ git checkout master Switched to branch ‘master’ 然后，敲命令git tag就可以打一个新标签： $ git tag v1.0 可以用命令git tag查看所有标签： $ git tag v1.0 默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？ 方法是找到历史提交的commit id，然后打上就可以了： $ git log –pretty=oneline –abbrev-commit 6a5819e merged bug fix 101 cc17032 fix bug 101 7825a50 merge with no-ff 6224937 add merge 59bc1cb conflict fixed 400b400 &amp; simple 75a857c AND simple fec145a branch test d17efd8 remove test.txt … 比方说要对add merge这次提交打标签，它对应的commit id是6224937，敲入命令： $ git tag v0.9 6224937 再用命令git tag查看标签： $ git tag v0.9 v1.0 注意，标签不是按时间顺序列出，而是按字母排序的。可以用git show查看标签信息： $ git show v0.9 commit 622493706ab447b6bb37e4e2a2f276a20fed2ab4 Author: Michael Liao &#x61;&#115;&#x6b;&#120;&#x75;&#101;&#102;&#101;&#x6e;&#103;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#111;&#x6d; Date: Thu Aug 22 11:22:08 2013 +0800 add merge … 可以看到，v0.9确实打在add merge这次提交上。 还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字： $ git tag -a v0.1 -m “version 0.1 released” 3628164 用命令git show可以看到说明文字： $ git show v0.1 tag v0.1 Tagger: Michael Liao &#x61;&#115;&#x6b;&#120;&#117;&#x65;&#102;&#101;&#110;&#x67;&#64;&#103;&#x6d;&#97;&#105;&#108;&#46;&#99;&#111;&#x6d; Date: Mon Aug 26 07:28:11 2013 +0800 version 0.1 released commit 3628164fb26d48395383f8f31179f24e0882e1e0 Author: Michael Liao &#x61;&#115;&#107;&#x78;&#x75;&#x65;&#102;&#x65;&#110;&#x67;&#x40;&#103;&#109;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109; Date: Tue Aug 20 15:11:49 2013 +0800 append GPL 还可以通过-s用私钥签名一个标签： $ git tag -s v0.2 -m “signed version 0.2 released” fec145a 签名采用PGP签名，因此，必须首先安装gpg（GnuPG），如果没有找到gpg，或者没有gpg密钥对，就会报错： gpg: signing failed: secret key not available error: gpg failed to sign the data error: unable to sign the tag 如果报错，请参考GnuPG帮助文档配置Key。 用命令git show可以看到PGP签名信息： $ git show v0.2 tag v0.2 Tagger: Michael Liao &#x61;&#115;&#x6b;&#120;&#x75;&#x65;&#x66;&#101;&#x6e;&#103;&#64;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#109; Date: Mon Aug 26 07:28:33 2013 +0800 signed version 0.2 released —–BEGIN PGP SIGNATURE—– Version: GnuPG v1.4.12 (Darwin) iQEcBAABAgAGBQJSGpMhAAoJEPUxHyDAhBpT4QQIAKeHfR3bo… —–END PGP SIGNATURE—– commit fec145accd63cdc9ed95a2f557ea0658a2a6537f Author: Michael Liao &#97;&#x73;&#107;&#120;&#117;&#x65;&#x66;&#101;&#x6e;&#x67;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#109; Date: Thu Aug 22 10:37:30 2013 +0800 branch test 用PGP签名的标签是不可伪造的，因为可以验证PGP签名。验证签名的方法比较复杂，这里就不介绍了。 小结 命令git tag用于新建一个标签，默认为HEAD，也可以指定一个commit id； git tag -a -m &quot;blablabla...&quot;可以指定标签信息； git tag -s -m &quot;blablabla...&quot;可以用PGP签名标签； 命令git tag可以查看所有标签。 操作标签如果标签打错了，也可以删除： $ git tag -d v0.1 Deleted tag ‘v0.1’ (was e078af9) 因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。 如果要推送某个标签到远程，使用命令git push origin： $ git push origin v1.0 Total 0 (delta 0), reused 0 (delta 0) To git@github.com:michaelliao/learngit.git * [new tag] v1.0 -> v1.0 或者，一次性推送全部尚未推送到远程的本地标签： $ git push origin –tags Counting objects: 1, done. Writing objects: 100% (1/1), 554 bytes, done. Total 1 (delta 0), reused 0 (delta 0) To git@github.com:michaelliao/learngit.git * [new tag] v0.2 -> v0.2 * [new tag] v0.9 -> v0.9 如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除： $ git tag -d v0.9 Deleted tag ‘v0.9’ (was 6224937) 然后，从远程删除。删除命令也是push，但是格式如下： $ git push origin :refs/tags/v0.9 To git@github.com:michaelliao/learngit.git - [deleted] v0.9 要看看是否真的从远程库删除了标签，可以登陆GitHub查看。 小结 命令git push origin可以推送一个本地标签； 命令git push origin --tags可以推送全部未推送过的本地标签； 命令git tag -d可以删除一个本地标签； 命令git push origin :refs/tags/可以删除一个远程标签。 使用GitHub我们一直用GitHub作为免费的远程仓库，如果是个人的开源项目，放到GitHub上是完全没有问题的。其实GitHub还是一个开源协作社区，通过GitHub，既可以让别人参与你的开源项目，也可以参与别人的开源项目。 在GitHub出现以前，开源项目开源容易，但让广大人民群众参与进来比较困难，因为要参与，就要提交代码，而给每个想提交代码的群众都开一个账号那是不现实的，因此，群众也仅限于报个bug，即使能改掉bug，也只能把diff文件用邮件发过去，很不方便。 但是在GitHub上，利用Git极其强大的克隆和分支功能，广大人民群众真正可以第一次自由参与各种开源项目了。 如何参与一个开源项目呢？比如人气极高的bootstrap项目，这是一个非常强大的CSS框架，你可以访问它的项目主页https://github.com/twbs/bootstrap，点“Fork”就在自己的账号下克隆了一个bootstrap仓库，然后，从自己的账号下clone： git clone git@github.com:michaelliao/bootstrap.git 一定要从自己的账号下clone仓库，这样你才能推送修改。如果从bootstrap的作者的仓库地址`git@github.com:twbs/bootstrap.git`克隆，因为没有权限，你将不能推送修改。 Bootstrap的官方仓库twbs/bootstrap、你在GitHub上克隆的仓库my/bootstrap，以及你自己克隆到本地电脑的仓库，他们的关系就像下图显示的那样： 如果你想修复bootstrap的一个bug，或者新增一个功能，立刻就可以开始干活，干完后，往自己的仓库推送。 如果你希望bootstrap的官方库能接受你的修改，你就可以在GitHub上发起一个pull request。当然，对方是否接受你的pull request就不一定了。 如果你没能力修改bootstrap，但又想要试一把pull request，那就Fork一下我的仓库：https://github.com/michaelliao/learngit，创建一个your-github-id.txt的文本文件，写点自己学习Git的心得，然后推送一个pull request给我，我会视心情而定是否接受。 小结 在GitHub上，可以任意Fork开源仓库； 自己拥有Fork后的仓库的读写权限； 可以推送pull request给官方仓库来贡献代码。 自定义Git在安装Git一节中，我们已经配置了user.name和user.email，实际上，Git还有很多可配置项。 比如，让Git显示颜色，会让命令输出看起来更醒目： $ git config –global color.ui true 这样，Git会适当地显示不同的颜色，比如git status命令： 文件名就会标上颜色。 我们在后面还会介绍如何更好地配置Git，以便让你的工作更高效。 忽略特殊文件有些时候，你必须把某些文件放到Git工作目录中，但又不能提交它们，比如保存了数据库密码的配置文件啦，等等，每次git status都会显示Untracked files ...，有强迫症的童鞋心里肯定不爽。 好在Git考虑到了大家的感受，这个问题解决起来也很简单，在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。 不需要从头写.gitignore文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览：https://github.com/github/gitignore 忽略文件的原则是： 忽略操作系统自动生成的文件，比如缩略图等； 忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件； 忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。 举个例子： 假设你在Windows下进行Python开发，Windows会自动在有图片的目录下生成隐藏的缩略图文件，如果有自定义目录，目录下就会有Desktop.ini文件，因此你需要忽略Windows自动生成的垃圾文件： # Windows: Thumbs.db ehthumbs.db Desktop.ini 然后，继续忽略Python编译产生的.pyc、.pyo、dist等文件或目录： # Python: *.py[cod] *.so *.egg *.egg-info dist build 加上你自己定义的文件，最终得到一个完整的.gitignore文件，内容如下： # Windows: Thumbs.db ehthumbs.db Desktop.ini # Python: *.py[cod] *.so *.egg *.egg-info dist build # My configurations: db.ini deploy_key_rsa 最后一步就是把.gitignore也提交到Git，就完成了！当然检验.gitignore的标准是git status命令是不是说working directory clean。 使用Windows的童鞋注意了，如果你在资源管理器里新建一个.gitignore文件，它会非常弱智地提示你必须输入文件名，但是在文本编辑器里“保存”或者“另存为”就可以把文件保存为.gitignore了。 小结 忽略某些文件时，需要编写.gitignore； .gitignore文件本身要放到版本库里，并且可以对.gitignore做版本管理！ 配置别名有没有经常敲错命令？比如git status？status这个单词真心不好记。 如果敲git st就表示git status那就简单多了，当然这种偷懒的办法我们是极力赞成的。 我们只需要敲一行命令，告诉Git，以后st就表示status： $ git config –global alias.st status 好了，现在敲git st看看效果。 当然还有别的命令可以简写，很多人都用co表示checkout，ci表示commit，br表示branch： $ git config –global alias.co checkout $ git config –global alias.ci commit $ git config –global alias.br branch 以后提交就可以简写成： $ git ci -m “bala bala bala…” --global参数是全局参数，也就是这些命令在这台电脑的所有Git仓库下都有用。 在撤销修改一节中，我们知道，命令git reset HEAD file可以把暂存区的修改撤销掉（unstage），重新放回工作区。既然是一个unstage操作，就可以配置一个unstage别名： $ git config –global alias.unstage ‘reset HEAD’ 当你敲入命令： $ git unstage test.py 实际上Git执行的是： $ git reset HEAD test.py 配置一个git last，让其显示最后一次提交信息： $ git config –global alias.last ‘log -1’ 这样，用git last就能显示最近一次的提交： $ git last commit adca45d317e6d8a4b23f9811c3d7b7f0f180bfe2 Merge: bd6ae48 291bea8 Author: Michael Liao &#x61;&#115;&#x6b;&#120;&#117;&#101;&#x66;&#x65;&#x6e;&#103;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d; Date: Thu Aug 22 22:49:22 2013 +0800 merge &amp; fix hello.py 甚至还有人丧心病狂地把lg配置成了： git config –global alias.lg “log –color –graph –pretty=format:’%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset’ –abbrev-commit” 来看看git lg的效果： 为什么不早点告诉我？别激动，咱不是为了多记几个英文单词嘛！ 配置文件配置Git的时候，加上--global是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。 配置文件放哪了？每个仓库的Git配置文件都放在.git/config文件中： $ cat .git/config [core] repositoryformatversion = 0 filemode = true bare = false logallrefupdates = true ignorecase = true precomposeunicode = true [remote “origin”] url = git@github.com:michaelliao/learngit.git fetch = +refs/heads/*:refs/remotes/origin/* [branch “master”] remote = origin merge = refs/heads/master [alias] last = log -1 别名就在[alias]后面，要删除别名，直接把对应的行删掉即可。 而当前用户的Git配置文件放在用户主目录下的一个隐藏文件.gitconfig中： $ cat .gitconfig [alias] co = checkout ci = commit br = branch st = status [user] name = Your Name email = your@email.com 配置别名也可以直接修改这个文件，如果改错了，可以删掉文件重新通过命令配置。 小结 给Git配置好别名，就可以输入命令时偷个懒。我们鼓励偷懒。 搭建Git服务器在远程仓库一节中，我们讲了远程仓库实际上和本地仓库没啥不同，纯粹为了7x24小时开机并交换大家的修改。 GitHub就是一个免费托管开源代码的远程仓库。但是对于某些视源代码如生命的商业公司来说，既不想公开源代码，又舍不得给GitHub交保护费，那就只能自己搭建一台Git服务器作为私有仓库使用。 搭建Git服务器需要准备一台运行Linux的机器，强烈推荐用Ubuntu或Debian，这样，通过几条简单的apt命令就可以完成安装。 假设你已经有sudo权限的用户账号，下面，正式开始安装。 第一步，安装git： $ sudo apt-get install git 第二步，创建一个git用户，用来运行git服务： $ sudo adduser git 第三步，创建证书登录： 收集所有需要登录的用户的公钥，就是他们自己的id_rsa.pub文件，把所有公钥导入到/home/git/.ssh/authorized_keys文件里，一行一个。 第四步，初始化Git仓库： 先选定一个目录作为Git仓库，假定是/srv/sample.git，在/srv目录下输入命令： $ sudo git init –bare sample.git Git就会创建一个裸仓库，裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以.git结尾。然后，把owner改为git： $ sudo chown -R git:git sample.git 第五步，禁用shell登录： 出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑/etc/passwd文件完成。找到类似下面的一行： git:x:1001:1001:,,,:/home/git:/bin/bash 改为： git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell 这样，git用户可以正常通过ssh使用git，但无法登录shell，因为我们为git用户指定的git-shell每次一登录就自动退出。 第六步，克隆远程仓库： 现在，可以通过git clone命令克隆远程仓库了，在各自的电脑上运行： $ git clone git@server:/srv/sample.git Cloning into ‘sample’… warning: You appear to have cloned an empty repository. 剩下的推送就简单了。 管理公钥如果团队很小，把每个人的公钥收集起来放到服务器的/home/git/.ssh/authorized_keys文件里就是可行的。如果团队有几百号人，就没法这么玩了，这时，可以用Gitosis来管理公钥。 这里我们不介绍怎么玩Gitosis了，几百号人的团队基本都在500强了，相信找个高水平的Linux管理员问题不大。 管理权限有很多不但视源代码如生命，而且视员工为窃贼的公司，会在版本控制系统里设置一套完善的权限控制，每个人是否有读写权限会精确到每个分支甚至每个目录下。因为Git是为Linux源代码托管而开发的，所以Git也继承了开源社区的精神，不支持权限控制。不过，因为Git支持钩子（hook），所以，可以在服务器端编写一系列脚本来控制提交等操作，达到权限控制的目的。Gitolite就是这个工具。 这里我们也不介绍Gitolite了，不要把有限的生命浪费到权限斗争中。 小结 搭建Git服务器非常简单，通常10分钟即可完成； 要方便管理公钥，用Gitosis； 要像SVN那样变态地控制权限，用Gitolite。 期末总结终于到了期末总结的时刻了！ 经过几天的学习，相信你对Git已经初步掌握。一开始，可能觉得Git上手比较困难，尤其是已经熟悉SVN的童鞋，没关系，多操练几次，就会越用越顺手。 Git虽然极其强大，命令繁多，但常用的就那么十来个，掌握好这十几个常用命令，你已经可以得心应手地使用Git了。 友情附赠国外网友制作的Git Cheat Sheet，建议打印出来备用： Git Cheat Sheet 现在告诉你Git的官方网站：http://git-scm.com，英文自我感觉不错的童鞋，可以经常去官网看看。什么，打不开网站？相信我，我给出的绝对是官网地址，而且，Git官网决没有那么容易宕机，可能是你的人品问题，赶紧面壁思过，好好想想原因。 如果你学了Git后，工作效率大增，有更多的空闲时间健身看电影，那我的教学目标就达到了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[企业级监控软件Zabbix安装]]></title>
    <url>%2F2018%2F09%2F13%2F%E4%BC%81%E4%B8%9A%E7%BA%A7%E7%9B%91%E6%8E%A7%E8%BD%AF%E4%BB%B6Zabbix%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[Zabbix 3.4 支持Centos 7，貌似不支持6.9。 Zabbix 是一个企业级的分布式开源监控方案。能够监控各种网络参数以及服务器健康性和完整性。支持灵活的通知机制，提供出色的报告和数据可视化功能。Zabbix支持主动轮询和被动捕获。最关键的是源代码都是免费发行的，可供公众任意使用。这也是它在中小企业广为流行的重要原因之一。本文简要描述Zabbix特性以及基于CentOS 7下安装Zabbix 3.4。 环境准备12345678910111213141516171819202122232425262728# more /etc/redhat-release ##演示环境CentOS Linux release 7.4.1708 (Core) # vi /etc/selinux/config ##关闭selinuxSELINUX=disabled# setenforce 0# yum install mariadb-server mariadb -y ##安装mariadb数据库# systemctl start mariadb# systemctl enable mariadb##添加zabbix yum源，安装zabbix server以及web管理# rpm -ivh http://repo.zabbix.com/zabbix/3.4/rhel/7/x86_64/zabbix-release-3.4-1.el7.centos.noarch.rpm# yum install zabbix-server-mysql zabbix-web-mysql -y # mysql ##登陆到mysql创建数据库及目录Welcome to the MariaDB monitor. Commands end with ; or \g.Your MariaDB connection id is 3Server version: 5.5.56-MariaDB MariaDB ServerMariaDB [(none)]&gt; create database zabbix character set utf8 collate utf8_bin;Query OK, 1 row affected (0.00 sec)MariaDB [(none)]&gt; grant all privileges on zabbix.* to zabbix@localhost identified by &apos;zabbix#1235&apos;;Query OK, 0 rows affected (0.00 sec)##将zabbix元数据添加到mariadb# zcat /usr/share/doc/zabbix-server-mysql-3.4.4/create.sql.gz | mysql -uzabbix -pzabbix#1235 zabbix Zabbix配置123456789101112131415161718192021222324252627# cp /etc/zabbix/zabbix_server.conf /etc/zabbix/zabbix_server.conf.1121# vim /etc/zabbix/zabbix_server.conf ##使用缺省配置，仅仅设定数据库密码DBPassword=zabbix#1235# vim /etc/httpd/conf.d/zabbix.conf ##修改apache zabbix时区php_value date.timezone Asia/Shanghai# cp /etc/httpd/conf/httpd.conf /etc/httpd/conf/httpd.conf.bk# vim /etc/httpd/conf/httpd.conf ##Author : LeshamiListen 3080 ##此处使用非缺省的80端口 ##Blog : http://blog.csdn.net/leshami启动相关服务 # systemctl start zabbix-server.service # systemctl enable zabbix-server.service # systemctl start httpd # systemctl enable httpd # netstat -nltp|egrep &quot;zabbix|httpd|mysql&quot; tcp 0 0 0.0.0.0:10051 0.0.0.0:* LISTEN 15720/zabbix_server tcp 0 0 0.0.0.0:3080 0.0.0.0:* LISTEN 15385/httpd tcp 0 0 0.0.0.0:3306 0.0.0.0:* LISTEN 14146/mysqld tcp6 0 0 :::10051 :::* LISTEN 15720/zabbix_server 防火墙配置# firewall-cmd --add-port=3080/tcp --permanent # firewall-cmd --add-port=10051/tcp --permanent # systemctl reload firewalld.service 安装图形界面打开浏览器，输入http://yourip:port/zabbix ，yourip是指安装zabbix-server端服务器的ip地址。 环境监测全部ok即可进入下一步，如果报错即根据提示安装缺失的依赖。 接下来配置到数据库的连接 服务器名称及端口配置 即可完成安装，登陆，缺省用户名Admin，密码zabbix 即可。]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>运维</tag>
        <tag>监控</tag>
        <tag>zabbix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Urllib库的基本使用]]></title>
    <url>%2F2018%2F09%2F13%2Furllib%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Urllib 库的基本使用分分钟扒一个网页下来怎样扒网页呢？其实就是根据URL来获取它的网页信息，虽然我们在浏览器中看到的是一幅幅优美的画面，但是其实是由浏览器解释才呈现出来的，实质它是一段 HTML 代码，加 JS、CSS，如果把网页比作一个人，那么 HTML 便是他的骨架，JS 便是他的肌肉，CSS 便是它的衣服。所以最重要的部分是存在于 HTML 中的，下面我们就写个例子来扒一个网页下来。 123import urllib2 response = urllib2.urlopen(&quot;http://www.baidu.com&quot;)print response.read() 是的你没看错，真正的程序就两行，把它保存成 demo.py，进入该文件的目录，执行如下命令查看运行结果，感受一下。 1python demo.py 分析扒网页的方法那么我们来分析这两行代码，第一行 1response = urllib2.urlopen(&quot;http://www.baidu.com&quot;) 首先我们调用的是 urllib2 库里面的 urlopen 方法，传入一个 URL，这个网址是百度首页，协议是 HTTP 协议，当然你也可以把 HTTP 换做 FTP,FILE,HTTPS 等等，只是代表了一种访问控制协议，urlopen 一般接受三个参数，它的参数如下： 1urlopen(url, data, timeout) 第一个参数 url 即为 URL，第二个参数 data 是访问 URL 时要传送的数据，第三个 timeout是设置超时时间。 第二三个参数是可以不传送的，data 默认为空 None，timeout 默认为 socket._GLOBAL_DEFAULT_TIMEOUT 第一个参数 URL 是必须要传送的，在这个例子里面我们传送了百度的 URL，执行 urlopen 方法之后，返回一个 response 对象，返回信息便保存在这里面。 1print response.read() response 对象有一个 read 方法，可以返回获取到的网页内容。 如果不加 read 直接打印会是什么？答案如下： 1&lt;addinfourl at 139728495260376 whose fp = &lt;socket._fileobject object at 0x7f1513fb3ad0&gt;&gt; 直接打印出了该对象的描述，所以记得一定要加 read 方法，否则它不出来内容可就不怪我咯！ 构造 Requset其实上面的 urlopen 参数可以传入一个 request 请求,它其实就是一个 Request 类的实例，构造时需要传入 Url,Data 等等的内容。比如上面的两行代码，我们可以这么改写 1234import urllib2request = urllib2.Request(&quot;http://www.baidu.com&quot;)response = urllib2.urlopen(request)print response.read() 运行结果是完全一样的，只不过中间多了一个 request 对象，推荐大家这么写，因为在构建请求时还需要加入好多内容，通过构建一个 request，服务器响应请求得到应答，这样显得逻辑上清晰明确。 POST 和 GET 数据传送上面的程序演示了最基本的网页抓取，不过，现在大多数网站都是动态网页，需要你动态地传递参数给它，它做出对应的响应。所以，在访问时，我们需要传递数据给它。最常见的情况是什么？对了，就是登录注册的时候呀。 把数据用户名和密码传送到一个 URL，然后你得到服务器处理之后的响应，这个该怎么办？下面让我来为小伙伴们揭晓吧！ 数据传送分为 POST 和 GET 两种方式，两种方式有什么区别呢？ 最重要的区别是 GET 方式是直接以链接形式访问，链接中包含了所有的参数，当然如果包含了密码的话是一种不安全的选择，不过你可以直观地看到自己提交了什么内容。POST 则不会在网址上显示所有的参数，不过如果你想直接查看提交了什么就不太方便了，大家可以酌情选择。 POST 方式： 上面我们说了 data 参数是干嘛的？对了，它就是用在这里的，我们传送的数据就是这个参数data，下面演示一下 POST 方式。 12345678import urllibimport urllib2values = &#123;&quot;username&quot;:&quot;1016903103@qq.com&quot;,&quot;password&quot;:&quot;XXXX&quot;&#125;data = urllib.urlencode(values) url = &quot;https://passport.csdn.net/account/login?from=http://my.csdn.net/my/mycsdn&quot;request = urllib2.Request(url,data)response = urllib2.urlopen(request)print response.read() 我们引入了 urllib 库，现在我们模拟登陆 CSDN，当然上述代码可能登陆不进去，因为还要做一些设置头部 header 的工作，或者还有一些参数没有设置全，还没有提及到在此就不写上去了，在此只是说明登录的原理。我们需要定义一个字典，名字为 values，参数我设置了 username 和 password，下面利用 urllib 的 urlencode 方法将字典编码，命名为 data，构建 request 时传入两个参数，url 和 data，运行程序，即可实现登陆，返回的便是登陆后呈现的页面内容。当然你可以自己搭建一个服务器来测试一下。 注意上面字典的定义方式还有一种，下面的写法是等价的 12345678910import urllibimport urllib2values = &#123;&#125;values[&apos;username&apos;] = &quot;1016903103@qq.com&quot;values[&apos;password&apos;] = &quot;XXXX&quot;data = urllib.urlencode(values) url = &quot;http://passport.csdn.net/account/login?from=http://my.csdn.net/my/mycsdn&quot;request = urllib2.Request(url,data)response = urllib2.urlopen(request)print response.read() 以上方法便实现了 POST 方式的传送 GET 方式： 至于 GET 方式我们可以直接把参数写到网址上面，直接构建一个带参数的 URL 出来即可。 12345678910import urllibimport urllib2values = &#123;&#125;values[&apos;username&apos;] = &quot;1016903103@qq.com&quot;values[&apos;password&apos;] = &quot;XXXX&quot;data = urllib.urlencode(values) url = &quot;http://passport.csdn.net/account/login?from=http://my.csdn.net/my/mycsdn&quot;request = urllib2.Request(url,data)response = urllib2.urlopen(request)print response.read() 你可以 print geturl，打印输出一下 url，发现其实就是原来的 url 加？然后加编码后的参数 1http://passport.csdn.net/account/login?username=1016903103%40qq.com&amp;password=XXXX 和我们平常 GET 访问方式一模一样，这样就实现了数据的 GET 方式传送。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬虫之路-01]]></title>
    <url>%2F2018%2F09%2F12%2FPython%E7%88%AC%E8%99%AB%E4%B9%8B%E8%B7%AF-001%2F</url>
    <content type="text"><![CDATA[从第一个爬虫开始1. 什么是爬虫 爬虫的全名叫网络爬虫，简称爬虫。爬虫是什么呢？爬虫有简单的爬虫和复杂的爬虫。实际上简单的爬虫是一种脚本。还有就是高级的爬虫了。高级的爬虫技术是非常难的。其实，类似谷歌Bing百度这种搜索引擎，本质上你也可以认为是一种爬虫。搜索引擎是如何工作的？其实就是通过网络爬虫技术，将互联网中数以百亿计的网页信息保存到本地，形成一个镜像文件，为整个搜索引擎提供数据支撑。 2.学习爬虫该掌握的 基本的Python语法知识；（参考廖雪峰的python教程） Python爬虫常用到的几个重要内置库Urllib, http等，用于下载网页； 正则表达式re、BeautifulSoup（bs4）、Xpath（lxml）等网页解析工具； 爬虫的一些反爬机制，header，robot，时间间隔，代理ip，隐含字段等; 特殊网站的爬取，解决登录、Cookie、动态网页等问题； 爬虫与数据库的结合，将爬取数据进行储存； 应用Python的多线程、多进程进行爬取； 爬虫的框架，Scrapy、PySpider等； 分布式爬虫 3.第一个爬虫Demo 在写第一个爬虫demo之前我们应该了解一些关于网页方面的知识 审查元素 在浏览器的地址栏输入URL地址，在网页处右键单击，找到检查，如下图所示：(不同浏览器的叫法不同，Chrome浏览器叫做检查，Firefox浏览器叫做查看元素，但是功能都是相同的) 然后我们就能打开chrome的开发者工具，搞前端的小伙伴可以深入了解一下。 我们可以看到，右侧出现了一大推代码即网页源码HTML，正如基因决定了我们的外貌一样，服务器返回的HTML决定了网站的原始容貌。浏览器是作为客户端从服务器端获取信息，将信息解析，并展示给我们的。我们可以利用开发工具在本地修改HTML信息，为网页”整容” 但是我们修改的信息不会回传到服务器，服务器存储的HTML信息不会改变。刷新一下界面，页面还会回到原本的样子。这就跟人整容一样，我们能改变一些表面的东西，但是不能改变我们的基因。 简单实例 网络爬虫的第一步就是根据URL，获取网页的HTML信息。在Python3中，可以使用urllib.request和requests进行网页爬取。 urllib库是python内置的，无需我们额外安装，只要安装了Python就可以使用这个库。 requests库是第三方库，需要我们自己安装。 requests库强大好用，所以本文使用requests库获取网页的HTML信息。requests库的github地址：https://github.com/requests/requests （1）requests安装 在学习使用requests库之前，我们需要在电脑中安装好requests库。在cmd中，使用如下指令安装requests库： 123pip install requestseasy_install requests 使用pip和easy_install都可以安装，二选一即可。 （2）简单实例 安装好requests库之后，我们先来大体浏览一下requests库的基础方法： requests库的开发者为我们提供了详细的官方教程，查询起来很方便。本文不会对其所有内容进行讲解，摘取其部分使用到的内容，进行实战说明。 首先，让我们看下requests.get()方法，它用于向服务器发起GET请求，不了解GET请求没有关系。我们可以这样理解：get的中文意思是得到、抓住，那这个requests.get()方法就是从服务器得到、抓住数据，也就是获取数据。让我们看一个例子(以 www.baidu.com为例)来加深理解： 123456# -*- coding:UTF-8 -*-import requestsif __name__ == '__main__': target = 'http://www.baidu.com/' req = requests.get(url=target) print(req.text) requests.get()方法必须设置的一个参数就是url，因为我们得告诉GET请求，我们的目标是谁，我们要获取谁的信息。我们将GET请求获得的响应内容存放到req变量中，然后使用req.text就可以获得HTML信息了。运行结果如下：]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你好，生活/Hello, life]]></title>
    <url>%2F2018%2F09%2F11%2F%E4%BD%A0%E5%A5%BD%EF%BC%8C%E7%94%9F%E6%B4%BB%2F</url>
    <content type="text"><![CDATA[欢迎你来到闰一先生的小站! Welcome to Mr. Yu Yi’s website! 这里主要是我日常记录随笔碎碎念的地方，欢迎==留言评论==~Here is mainly the place where my daily records are essays.. Welcome comments.2018.09.11利用工作时间闰一先生的小站初步建成🙃，了解一个东西就得把它做出来，了解一个人就该。。。。 Using the working hours Mr. Yu Yi’s website is initially completed. If you want to understand something, you have to make it. if u want to know one person,what should u do? 2018.09.12 完善了基础功能，算是有个基本人形，尝试写博文，开始挖坑，接入了评论功能，还想整个在线联系站长的功能，能力不足，尝试失败，先搁置了。然后加了看板娘，一只很可爱的小黑猫，欢迎调戏。 I perfected the basic function of the blog. It has an infrastructure. I tried to write a blog post and started to create trouble for myself. After that, I accessed the comment function. I also want to contact the webmaster’s function online, but because of myself Insufficient ability, this plan failed, so I had to put the plan on hold. Finally, I added a kanban girl to my website, a very cute little black cat, welcome to tease it. 2018.09.13打算给网站自动换背景的，但是我前端知识欠缺，网页优化不会，就不给自己的网站增加负担了，加入了站长工具，用pv统计访客，自己给自己刷了不少😂，下班回家吃鸡了好久，战争模式总是被同一个杀死，好气啊，雨林图不知是我太浪还是队友太菜，带不动带不动🙅‍，晚上很晚才洗澡，soul疯狂推送狗粮，这是赤裸裸的消费90后啊，失眠很久。哦，现在是14号了明天再写 。 I intend to make my website automatically change the background, but because of the lack of knowledge of my front end, I will not add webpage optimization, so I will not burden my website. Then I added the webmaster tool to the website and used pv to count the visitors. During this period, I brushed myself a lot of visitors😂. After going home, I finished the mobile version of PUBG for a long time. In war mode, I am always killed by the same player. I feel very angry, in the rainforest map mode, I don’t know if I am too careless or my teammates are too weak, they can not go to my rhythma🙅‍, I took a shower very late at night, Soul app crazy pushes themes about men and women, this is simply the soul after the naked consumption of post-90s, today insomnia for a long time. Oh, now is the 14th and I will write a blog post tomorrow. 2018.09.16人间不值得，今天要早点休息了 The world is not worthy of being so careful, I have to rest early today. 2018.09.17今天忘了带移动硬盘过来，blog的数据也没办法更新和上传了😥，因为台风下午两点才上班，结果服务器出了问题，加班到九点…… 2018.09.18有点气🙃昨天加班这么晚走的突然竟然忘了打卡，年轻人太心浮气躁，人事部的小姐姐给我们发了中秋节的购物卡，我就忍不住嘴角上扬了，上一秒还在算生活开销能不能再省省，想买新设备，心酸。。。 2018.09.19电脑修的好，备胎当到老。 2018.09.20想要的太多，而赚的太少。 2018.09.21取消置顶了，还是老老实实做人，勤勤恳恳做事吧。工作开始慢慢步入正轨了，住的地方网络很差，不知道有没有合适的网线牵一下。 2018.09.25emmmm,老实说放假是不愿意更私文的，假期生活太隐私😳 25号之前的报告，给你们看看，闰一先生的死站。 2018.09.26没有碎碎念了暂时，emmmm ​ ​ To be continued….]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
</search>
